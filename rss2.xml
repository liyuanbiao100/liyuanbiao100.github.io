<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>我的个人博客</title>
    <link>https://mliyuanbiao.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>知识整理</description>
    <pubDate>Wed, 08 Aug 2018 14:33:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>关于 Kotlin 几篇文章的一些讨论</title>
      <link>https://mliyuanbiao.github.io/post/95d4684d.html</link>
      <guid>https://mliyuanbiao.github.io/post/95d4684d.html</guid>
      <pubDate>Tue, 26 Jun 2018 05:25:29 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;抛弃-Java-改用-Kotlin-的六个月后，我后悔了&quot;&gt;&lt;a href=&quot;#抛弃-Java-改用-Kotlin-的六个月后，我后悔了&quot; class=&quot;headerlink&quot; title=&quot;抛弃 Java 改用 Kotlin
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="抛弃-Java-改用-Kotlin-的六个月后，我后悔了"><a href="#抛弃-Java-改用-Kotlin-的六个月后，我后悔了" class="headerlink" title="抛弃 Java 改用 Kotlin 的六个月后，我后悔了"></a>抛弃 Java 改用 Kotlin 的六个月后，我后悔了</h2><p>原文地址：<a href="https://blog.csdn.net/csdnnews/article/details/80746096" target="_blank" rel="noopener">https://blog.csdn.net/csdnnews/article/details/80746096</a></p><p>这篇文章我很早之前之前就看过了，是一片批判 Kotlin 的文章，一时间在各大技术论坛疯狂转载。由于我本人很喜欢 Kotlin ，所以只是粗略的看了一眼，并觉得作者是在放屁。上面做法并不符合我认真求学的风格，今天我决定认真的看看，仔细分析下。</p><p>文中举了很多例子说明 Kotlin 的不完美，甚至会降低工作效率。我觉得，尽管 Kotlin 不完美，因为任何一门编程语言都不可能尽善尽美，但是他是在 Java 的基础上，为了解决 Java 的一些设计缺陷而设计出来的语言，使用 Kotlin 能极大增加工作效率。</p><h3 id="名称遮蔽"><a href="#名称遮蔽" class="headerlink" title="名称遮蔽"></a>名称遮蔽</h3><p>作者认为这是 Koltin 的设计缺陷，试图通过警告信息来解决这个问题。我认为这是 Kotlin 的一个功能，并不属于缺陷，名称遮蔽并不会造成编程错误，在有些地方也有名称遮蔽的应用。</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Kotlin 的类型推断比 Java 强大不止一点点，Java 在 8 开始才对类型推断有比较好的支持，到了 10 才可以使用<code>var</code>来声明变量，通过类型推断而不需要显示声明变量类型。这一特性也只在局部作用域生效。现在<br>Java 的使用者里面有很多都是Android开发者，本人就是。Android 对 Java 新语法的支持并不是很良好，为了兼容以前的 Android 系统，开发者们不得不使用 Java7 甚至 Java6 的语法。Kotlin 的出现让这一切有了很大的改观。</p><h3 id="Null-安全类型"><a href="#Null-安全类型" class="headerlink" title="Null 安全类型"></a>Null 安全类型</h3><p>作者在描述 Kotlin 与Java 互操作的过程中不可避免的会产生第三种类型，<strong>平台类型</strong>，作者认为平台类型会让代表变得糟糕，误导你，会禁用 Kotlin 的 NULL 安全机制。</p><p>我觉得 Kotlin 为了要与 Java 实现100% 互操作而产生平台类型这是不可避免的，因为 Java 从一开始就没有这种安全机制，在 Java 语言中，每个类变量都有可能为 null 。正是因为这样，Kotlin 编译器才为了我们做了更多的事情，他并没有将所有的 Java 变量翻译成可空类型。</p><ul><li>基础类型是不可能为 null 的，在 Kotlin 中会作为不可空类型的存在</li><li>Kotlin编译器还支持识别<code>@Nullable</code> 和 <code>@NonNull</code> 注解，他们分别会被翻译为可空类型和非空类型，现在很多类库为了适应 Kotlin 而加上了这些注解。</li><li>当平台类型不可避免的时候，可以显示为 Java 变量声明可空类型或者非空类型，避免在 Kotlin 中使用平台类型。如果你没有遵守这一规则，Kotlin 编译器则会以警告的形式提示你。</li><li>Kotlin 有强大的 IDE 支持，在编辑器中会显示类型推断的实际类型。平台类型则是类型名称后面加上！。这只在编辑器中作为提示显示，语法中并不存在。</li></ul><p>Kotlin 并不会误导你，对语言的不熟悉才是你被误导的真正原因。我觉得 Kotlin有很多吸引我的地方，其中 Null 安全机制是我最喜欢的。</p><h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>在 Java8 中为了解决空安全的问题，而引入了Optional。作者称 如今，Optional 是在 API 边界处理返回类型中的空值的非常流行的方式。而我倒觉得这是非常无奈的做法，比起 Kotlin 从根源上解决查太多。</p><p>为了论证 Kotlin 很差，作者举了下面的例子：<br>例如，在 Java 中： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">parseAndInc</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(number)</span><br><span class="line">                   .map(Integer::parseInt)</span><br><span class="line">                   .map(it -&gt; it + <span class="number">1</span>)</span><br><span class="line">                   .orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，需要这样做</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseAndInc</span><span class="params">(number: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number?.let &#123; Integer.parseInt(it) &#125;</span><br><span class="line">                 ?.let &#123; it -&gt; it + <span class="number">1</span> &#125; ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后比较这两段代码的可读性。</p><p>可读性对于每个人都不一样吧，而且谁会在 kotlin 使用 <code>Integer.parseInt</code> 呢？如果作者喜欢 Optional ，你可以使用它。 Kotlin 在 JVM 上运行。即使是自己实现一个类似于 Optional 的类也是很容易的。</p><h3 id="类名称字面常量"><a href="#类名称字面常量" class="headerlink" title="类名称字面常量"></a>类名称字面常量</h3><p>这点我就不想多说了，作者纯粹为了找茬嘛。<br>文中说：Kotlin 把 Kotlin 类和 Java 类进行了区分，并为其提供了语法规范：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kotlinClass : KClass&lt;LocalDate&gt; = LocalDate::<span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="keyword">val</span> javaClass : Class&lt;LocalDate&gt; = LocalDate::<span class="class"><span class="keyword">class</span>.<span class="title">java</span></span></span><br></pre></td></tr></table></figure><p>这看起来非常丑陋。</p><p>丑陋，呵呵呵呵呵呵呵。。。。。<br>还有其他的一些点论证 Kotlin 无比丑陋的说法就不一一说明了。</p><p>另外作为认为 Kotlin 具有陡峭的学习路线，这点我是不认同的，我只用了两天就将 Kotlin 用于生产环境了。Groovy 虽然很容易从 Java 转换过来，因为Java代码是正确的 Groovy 代码，但是想要深入学习一点都不比 Kotlin 容易，特别是没有接触过弱类型语言的开发者来说。Groovy 我也学习过，我更认为同样作为静态类型的 Kotlin 与 Java 更接近，即使他的语法与 Scala 接近。</p><h3 id="关于作者最后的想法"><a href="#关于作者最后的想法" class="headerlink" title="关于作者最后的想法"></a>关于作者最后的想法</h3><blockquote><p>学习新技术就像一项投资。我们投入时间，新技术让我们得到回报。但我并不是说 Kotlin 是一种糟糕的语言，只是在我们的案例中，成本远超收益。</p></blockquote><p>作者说的是普遍的道理，所以我不能说他错，但是就目前而言我不认为 Kotlin 是糟糕的语言。使用 Kotlin 一年多时间以来，我感受到 Kotlin 带来的诸多好处，一种学习新语言，新特性带来的心灵洗礼，我不会说 Java 和 Kotlin 谁更好，他们都很好，我都很喜欢。</p><h2 id="谷歌大牛说：为什么-Kotlin-比你们用的那些垃圾语言都好"><a href="#谷歌大牛说：为什么-Kotlin-比你们用的那些垃圾语言都好" class="headerlink" title="谷歌大牛说：为什么 Kotlin 比你们用的那些垃圾语言都好"></a>谷歌大牛说：为什么 Kotlin 比你们用的那些垃圾语言都好</h2><p>原文地址：<a href="http://blog.jobbole.com/111249/" target="_blank" rel="noopener">http://blog.jobbole.com/111249/</a></p><p>这篇文章在安卓团队在谷歌 I/O 2017 大会上宣布 Kotlin 成为官方头等支持语言之后发布，同样获得疯狂的转载。这篇文章的标题有点标题党，甚至有点引战的味道。要让我用一个词来形容就是跪舔。</p><p>作者讲述了十年来的经历，以及为什么使用 Kotlin 。<br>比如 Android 有几个很糟糕的 API。因为这样，接下来一年半没有碰 Android 编程。来自俄罗斯的救星 Kotlin，对他第一印象是简洁，而且有一种似曾相识的感觉，和 Swift 很像，然后简述 Kotlin 和 Swift 的历史，是 Kotlin 在前，Swift 在后，所以是 Swift 和 Kotlin 很像。<br>其实谁和谁像已经无所谓了， Kotlin 和 Swift 都是现代化语言，而现在化语言都是很像的，作者花了大篇幅只为争个先后，这是跪舔。</p><p>接下里说为什么要从 Java 叛逃到 Kotlin。大部分是讲和 Java8 的对比，还有在 Android开发上的便利性，这和标题有个毛关系。回到糟糕的Android API，原文说：</p><blockquote><p>Kotlin 致力于让大家绕过 Android API 那些恶心的东西，并且能让你充分发挥你的经验，这一点甚至比 iOS 做得还要好。好吧，至少来说比 Objective-C 做得好，因为我觉得 Swift 肯定也不会差。知道为什么吗？因为 Swift 和 Kotlin 很像啊。</p></blockquote><p>Swift 和 Objective-C 只是在互操作性没有 Kotlin 与 Java 这么好，没办法，他们都是基础JVM的（我知道有人要杠了），这个 Android API 本身没有关系吧，API就在哪里，你用与不用，他都在哪里，请问 Kotlin 是如何绕过去的。 可能作者根本不喜欢 Android 吧，不然怎么会因为 Java 拒绝 Android，语句中看不出丝毫热爱。可能是为了跪舔而扯上的Android吧，但似乎有点用力过猛了。这也是跪舔。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/95d4684d.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>让Java类在kotlin中也支持解构声明</title>
      <link>https://mliyuanbiao.github.io/post/dced847d.html</link>
      <guid>https://mliyuanbiao.github.io/post/dced847d.html</guid>
      <pubDate>Thu, 08 Feb 2018 03:34:57 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;关于&lt;code&gt;kotlin&lt;/code&gt;的一大段介绍我就不说了，首先我们来看看结构声明在&lt;code&gt;kotlin&lt;/code&gt;中是如何使用的。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>关于<code>kotlin</code>的一大段介绍我就不说了，首先我们来看看结构声明在<code>kotlin</code>中是如何使用的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义一个Person类</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String? = <span class="literal">null</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (name, age) = Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>)</span><br><span class="line">    println(name) <span class="comment">// zhangsan</span></span><br><span class="line">    println(age) <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// ===等价于===</span></span><br><span class="line">    <span class="keyword">val</span> p = Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>)</span><br><span class="line">    println(p.name) <span class="comment">// zhangsan</span></span><br><span class="line">    println(p.age) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时把一个对象 解构 成很多变量会很方便，我们可以同时声明多个变量<br>一个解构声明会被编译成以下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = p.component1() <span class="comment">// zhangsan</span></span><br><span class="line"><span class="keyword">val</span> age = p.component2() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>其中<code>component1()</code>,<code>component2()</code>,<code>componentN()</code>函数是由Kotlin编译器自动生成的，方法的数量取决于属性的数量，方法的顺序取决于属性的顺序。</p><p>我们用Kotlin插件的<code>Show Kotlin Bytecode</code>功能将<code>Person</code>反编译可以得到如下Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span> <span class="comment">// String?类型隐含添加上@Nullable注解，在Java调用Kotlin时能给出友好地非空提示</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">   <span class="comment">// Int类型会被翻译成基本类型int，只有需要用到方法时才会转成Integer</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   ... setter/getter ... </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(@Nullable String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">component1</span><span class="params">()</span> </span>&#123; <span class="comment">// 第一个属性</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">component2</span><span class="params">()</span> </span>&#123; <span class="comment">// 第二个属性</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Person <span class="title">copy</span><span class="params">(@Nullable String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ... toString/hashCode/equals ... </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，<code>data class</code>除了自动生成<code>setter/getter</code>，<code>toString</code>，<code>equals</code>，<code>hashCode</code>之外，还有<code>component1</code>和<code>component2</code>。但是<code>Java</code>编译器是不会自动生成的，也就无法使用结构声明。</p><p>我们可以手动添加吗？？？？ 答案是可以的，你可以在<code>Person</code>类(Java)里面添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">component1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">component2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法可行，但似乎不够完美，我们大部分使用的API都是无法更改其内部结构的。根本没办法手动添加。</p><p>其实<code>Kotlin</code>是支持结构声明扩展的，你可以这么做</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. operator关键字必不可少</span></span><br><span class="line"><span class="comment">// 2. 为什么我这里显示声明**String?**呢？</span></span><br><span class="line"><span class="comment">// Person是Java类，getName()返回的是Java的平台类型(String!),而不是String或者String?，可空性未知</span></span><br><span class="line"><span class="comment">// 你应当显示声明name是否可空，以便更好运用Kotlin空安全的特性。</span></span><br><span class="line"><span class="comment">// 当然你也可以不添加，因此你会得到一个波浪线和一个黄色感叹号，但是这并不会影响程序的运行</span></span><br><span class="line"><span class="comment">// 而int类型是基本类型，编译成Int类型是一定非空的，开发工具不会因此报出警告。</span></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Person.<span class="title">component1</span><span class="params">()</span></span>: String? = name </span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Person.<span class="title">component2</span><span class="params">()</span></span> = age</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (name, age) = Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>)</span><br><span class="line">    println(name)</span><br><span class="line">    println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这里，我想同学们都很清楚知道如何使用结构声明扩展让Java类也支持结构声明了，真是可以可贺。</p><p>你可能见过下面一段代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123;</span><br><span class="line"><span class="comment">// 使用该 key、value 做些事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段遍历map的方法，实现它我们只需要这样做</p><ul><li>通过提供一个 <code>iterator()</code> 函数将映射表示为一个值的序列；</li><li>通过提供函数component1() 和 component2() 来将每个元素呈现为一对。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operator fun &lt;K, V&gt; Map&lt;K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entrySet().itera</span><br><span class="line">tor()</span><br><span class="line">operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component1() = getKey()</span><br><span class="line">operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component2() = getValue()</span><br></pre></td></tr></table></figure><p>题外话：其实kotlin标准库已经实现了一些很方便的扩展，包括上述的。<code>kotlin</code>拥有<code>java</code>所不具有的诸多优点，在谷歌大力支持下，我觉得Android开发者都应该学习并使用这门语言。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/dced847d.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>kotlin编译 Kotlin home does not exist or is not a directory</title>
      <link>https://mliyuanbiao.github.io/post/1f2f4db2.html</link>
      <guid>https://mliyuanbiao.github.io/post/1f2f4db2.html</guid>
      <pubDate>Sat, 03 Feb 2018 19:19:36 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;虽然kotlin成为谷歌干儿子才半年之久，但是我依然早早的在项目中使用它。秉承着早入坑早脱坑的理念，我遇到了下面这个问题。代码没有报错，但是编译不通过。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>虽然kotlin成为谷歌干儿子才半年之久，但是我依然早早的在项目中使用它。秉承着早入坑早脱坑的理念，我遇到了下面这个问题。代码没有报错，但是编译不通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e: Kotlin home does not exist or is not a directory:</span><br></pre></td></tr></table></figure><p>这个问题原因不明，莫名其妙出现的。代码完全没有问题，但是就是不能编译。<br>下面是解决方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">killall java</span><br><span class="line">./gradlew clean assemble</span><br></pre></td></tr></table></figure><p>解决原理不清楚。</p><p>下面是相关连接<br><a href="https://discuss.kotlinlang.org/t/task-compilekotlin2js-fails-in-gradle-4-4-kotlin-home-does-not-exist-or-is-not-a-directory/5706/3" target="_blank" rel="noopener">https://discuss.kotlinlang.org/t/task-compilekotlin2js-fails-in-gradle-4-4-kotlin-home-does-not-exist-or-is-not-a-directory/5706/3</a></p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/1f2f4db2.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android蓝牙</title>
      <link>https://mliyuanbiao.github.io/post/639eaf27.html</link>
      <guid>https://mliyuanbiao.github.io/post/639eaf27.html</guid>
      <pubDate>Thu, 21 Dec 2017 07:15:57 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;Android 平台包含蓝牙网络堆栈支持，凭借此项支持，设备能以无线方式与其他蓝牙设备交换数据。应用框架提供了通过 Android Bluetooth API 访问蓝牙功能的途径。 这些 API
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Android 平台包含蓝牙网络堆栈支持，凭借此项支持，设备能以无线方式与其他蓝牙设备交换数据。应用框架提供了通过 Android Bluetooth API 访问蓝牙功能的途径。 这些 API 允许应用以无线方式连接到其他蓝牙设备，从而实现点到点和多点无线功能。</p><ul><li>使用 Bluetooth API，Android 应用可执行以下操作：</li><li>扫描其他蓝牙设备</li><li>查询本地蓝牙适配器的配对蓝牙设备</li><li>建立 RFCOMM 通道</li><li>通过服务发现连接到其他设备</li><li>与其他设备进行双向数据传输</li><li>管理多个连接</li></ul><p>本文将介绍如何使用传统蓝牙。传统蓝牙适用于电池使用强度较大的操作，例如 Android 设备之间的流式传输和通信等。 针对具有低功耗要求的蓝牙设备，Android 4.3（API 级别 18）中引入了面向低功耗蓝牙的 API 支持。 如需了解更多信息，请参阅<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html" target="_blank" rel="noopener">低功耗蓝牙</a>。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>本文将介绍如何使用 Android Bluetooth API 来完成使用蓝牙进行通信的四项主要任务：设置蓝牙、查找局部区域内的配对设备或可用设备、连接设备，以及在设备之间传输数据。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/package-summary.html" target="_blank" rel="noopener">android.bluetooth</a> 包中提供了所有 Bluetooth API。 下面概要列出了创建蓝牙连接所需的类和接口：</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a><br>表示本地蓝牙适配器（蓝牙无线装置）。 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a> 是所有蓝牙交互的入口点。 利用它可以发现其他蓝牙设备，查询绑定（配对）设备的列表，使用已知的 MAC 地址实例化 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html" target="_blank" rel="noopener">BluetoothDevice</a>，以及创建 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 以侦听来自其他设备的通信。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html" target="_blank" rel="noopener">BluetoothDevice</a><br>表示远程蓝牙设备。利用它可以通过 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 请求与某个远程设备建立连接，或查询有关该设备的信息，例如设备的名称、地址、类和绑定状态等。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a><br>表示蓝牙套接字接口（与 TCP Socket 相似）。这是允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据的连接点。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a><br>表示用于侦听传入请求的开放服务器套接字（类似于 TCP <a href="https://developer.android.google.cn/reference/java/net/ServerSocket.html" target="_blank" rel="noopener">ServerSocket</a>）。 要连接两台 Android 设备，其中一台设备必须使用此类开放一个服务器套接字。 当一台远程蓝牙设备向此设备发出连接请求时， <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 将会在接受连接后返回已连接的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothClass.html" target="_blank" rel="noopener">BluetoothClass</a><br>描述蓝牙设备的一般特征和功能。 这是一组只读属性，用于定义设备的主要和次要设备类及其服务。 不过，它不能可靠地描述设备支持的所有蓝牙配置文件和服务，而是适合作为设备类型提示。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.html" target="_blank" rel="noopener">BluetoothProfile</a><br>表示蓝牙配置文件的接口。 蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。 免提配置文件便是一个示例。 如需了解有关配置文件的详细讨论，请参阅使用配置文件</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHeadset.html" target="_blank" rel="noopener">BluetoothHeadset</a><br>提供蓝牙耳机支持，以便与手机配合使用。 其中包括蓝牙耳机和免提（1.5 版）配置文件。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothA2dp.html" target="_blank" rel="noopener">BluetoothA2dp</a><br>定义高质量音频如何通过蓝牙连接和流式传输，从一台设备传输到另一台设备。“A2DP”代表高级音频分发配置文件。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealth.html" target="_blank" rel="noopener">BluetoothHealth</a><br>表示用于控制蓝牙服务的健康设备配置文件代理。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthCallback.html" target="_blank" rel="noopener">BluetoothHealthCallback</a><br>用于实现 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealth.html" target="_blank" rel="noopener">BluetoothHealth</a> 回调的抽象类。您必须扩展此类并实现回调方法，以接收关于应用注册状态和蓝牙通道状态变化的更新内容。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthAppConfiguration.html" target="_blank" rel="noopener">BluetoothHealthAppConfiguration</a><br>表示第三方蓝牙健康应用注册的应用配置，以便与远程蓝牙健康设备通信。</p><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.ServiceListener.html" target="_blank" rel="noopener">BluetoothProfile.ServiceListener</a><br>在 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.html" target="_blank" rel="noopener">BluetoothProfile</a> IPC 客户端连接到服务（即，运行特定配置文件的内部服务）或断开服务连接时向其发送通知的接口。</p><h1 id="蓝牙权限"><a href="#蓝牙权限" class="headerlink" title="蓝牙权限"></a>蓝牙权限</h1><p>要在应用中使用蓝牙功能，必须声明蓝牙权限 <a href="https://developer.android.google.cn/reference/android/Manifest.permission.html#BLUETOOTH" target="_blank" rel="noopener">BLUETOOTH</a>。您需要此权限才能执行任何蓝牙通信，例如请求连接、接受连接和传输数据等。</p><p>如果您希望您的应用启动设备发现或操作蓝牙设置，则还必须声明 <a href="https://developer.android.google.cn/reference/android/Manifest.permission.html#BLUETOOTH_ADMIN" target="_blank" rel="noopener">BLUETOOTH_ADMIN</a> 权限。 大多数应用需要此权限仅仅为了能够发现本地蓝牙设备。 除非该应用是将要应用户请求修改蓝牙设置的“超级管理员”，否则不应使用此权限所授予的其他能力。 注：如果要使用 <a href="https://developer.android.google.cn/reference/android/Manifest.permission.html#BLUETOOTH_ADMIN" target="_blank" rel="noopener">BLUETOOTH_ADMIN</a> 权限，则还必须拥有 <a href="https://developer.android.google.cn/reference/android/Manifest.permission.html#BLUETOOTH" target="_blank" rel="noopener">BLUETOOTH</a> 权限。</p><p>在您的应用清单文件中声明蓝牙权限。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如需了解有关声明应用权限的更多信息，请参阅 <a href="https://developer.android.google.cn/guide/topics/manifest/uses-permission-element.html" target="_blank" rel="noopener"><uses-permission></uses-permission></a> 参考资料。</p><h1 id="设置蓝牙"><a href="#设置蓝牙" class="headerlink" title="设置蓝牙"></a>设置蓝牙</h1><p><img src="/media/15138410782966.png" alt=""><br>图 1：启用蓝牙对话框。</p><p>您需要验证设备支持蓝牙，并且如果支持确保将其启用，然后您的应用才能通过蓝牙进行通信。</p><p>如果不支持蓝牙，则应正常停用任何蓝牙功能。 如果支持蓝牙但已停用此功能，则可以请求用户在不离开应用的同时启用蓝牙。 可使用 BluetoothAdapter，分两步完成此设置：</p><ol><li><p>获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a></p><p> 所有蓝牙 Activity 都需要 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a>。 要获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a>，请调用静态 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#getDefaultAdapter(" target="_blank" rel="noopener">getDefaultAdapter()</a>) 方法。这将返回一个表示设备自身的蓝牙适配器（蓝牙无线装置）的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a>。 整个系统有一个蓝牙适配器，并且您的应用可使用此对象与之交互。 如果 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#getDefaultAdapter(" target="_blank" rel="noopener">getDefaultAdapter()</a>) 返回 null，则该设备不支持蓝牙，您的操作到此为止。 例如： </p></li></ol><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line"><span class="keyword">if</span> (mBluetoothAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Device does not support Bluetooth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>启动蓝牙</p><p>下一步，您需要确保已启用蓝牙。调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#isEnabled(" target="_blank" rel="noopener">isEnabled()</a>) 以检查当前是否已启用蓝牙。 如果此方法返回 false，则表示蓝牙处于停用状态。要请求启用蓝牙，请使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#ACTION_REQUEST_ENABLE" target="_blank" rel="noopener">ACTION_REQUEST_ENABLE</a> 操作 Intent 调用 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int" target="_blank" rel="noopener">startActivityForResult()</a>)。这将通过系统设置发出启用蓝牙的请求（无需停止您的应用）。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">    Intent enableBtIntent = <span class="keyword">new</span> Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图 1 所示，将显示对话框，请求用户允许启用蓝牙。如果用户响应“Yes”，系统将开始启用蓝牙，并在该进程完成（或失败）后将焦点返回到您的应用。</p><p>传递给 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int" target="_blank" rel="noopener">startActivityForResult()</a>) 的 REQUEST_ENABLE_BT 常量是在局部定义的整型（必须大于 0），系统会将其作为 requestCode 参数传递回您的 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#onActivityResult(int, int, android.content.Intent" target="_blank" rel="noopener">onActivityResult()</a>) 实现。</p><p>如果成功启用蓝牙，您的 Activity 将会在 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#onActivityResult(int, int, android.content.Intent" target="_blank" rel="noopener">onActivityResult()</a>) 回调中收到 RESULT_OK 结果代码。 如果由于某个错误（或用户响应“No”）而没有启用蓝牙，则结果代码为 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#RESULT_CANCELED" target="_blank" rel="noopener">RESULT_CANCELED</a>。</p></li></ol><p>您的应用还可以选择侦听 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#ACTION_STATE_CHANGED" target="_blank" rel="noopener">ACTION_STATE_CHANGED</a> 广播 Intent，每当蓝牙状态发生变化时，系统都会广播此 Intent。 此广播包含额外字段 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#EXTRA_STATE" target="_blank" rel="noopener">EXTRA_STATE</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#EXTRA_PREVIOUS_STATE" target="_blank" rel="noopener">EXTRA_PREVIOUS_STATE</a>，二者分别包含新的和旧的蓝牙状态。 这些额外字段可能的值包括 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#STATE_TURNING_ON" target="_blank" rel="noopener">STATE_TURNING_ON</a>、<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#STATE_ON" target="_blank" rel="noopener">STATE_ON</a>、<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#STATE_TURNING_OFF" target="_blank" rel="noopener">STATE_TURNING_OFF</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#STATE_OFF" target="_blank" rel="noopener">STATE_OFF</a>。侦听此广播适用于检测在您的应用运行期间对蓝牙状态所做的更改。</p><blockquote><p><strong>提示</strong>：启用可检测性将会自动启用蓝牙。 如果您计划在执行蓝牙 Activity 之前一直启用设备的可检测性，则可以跳过上述步骤 2。 阅读下面的<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#EnablingDiscoverability" target="_blank" rel="noopener">启用可检测性</a>。</p></blockquote><h1 id="查找设备"><a href="#查找设备" class="headerlink" title="查找设备"></a>查找设备</h1><p>使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html" target="_blank" rel="noopener">BluetoothAdapter</a>，您可以通过设备发现或通过查询配对（绑定）设备的列表来查找远程蓝牙设备。</p><p>设备发现是一个扫描过程，它会搜索局部区域内已启用蓝牙功能的设备，然后请求一些关于各台设备的信息（有时也被称为“发现”、“查询”或“扫描”）。但局部区域内的蓝牙设备仅在其当前已启用可检测性时才会响应发现请求。 如果设备可检测到，它将通过共享一些信息（例如设备名称、类及其唯一 MAC 地址）来响应发现请求。 利用此信息，执行发现的设备可以选择发起到被发现设备的连接。</p><p>在首次与远程设备建立连接后，将会自动向用户显示配对请求。 设备完成配对后，将会保存关于该设备的基本信息（例如设备名称、类和 MAC 地址），并且可使用 Bluetooth API 读取这些信息。 利用远程设备的已知 MAC 地址可随时向其发起连接，而无需执行发现操作（假定该设备处于有效范围内）。</p><p>请记住，被配对与被连接之间存在差别。被配对意味着两台设备知晓彼此的存在，具有可用于身份验证的共享链路密钥，并且能够与彼此建立加密连接。 被连接意味着设备当前共享一个 RFCOMM 通道，并且能够向彼此传输数据。 当前的 Android Bluetooth API 要求对设备进行配对，然后才能建立 RFCOMM 连接。 （在使用 Bluetooth API 发起加密连接时，会自动执行配对）。</p><p>以下几节介绍如何查找已配对的设备，或使用设备发现来发现新设备。</p><blockquote><p><strong>注</strong>：Android 设备默认处于不可检测到状态。 用户可通过系统设置将设备设为在有限的时间内处于可检测到状态，或者，应用可请求用户在不离开应用的同时启用可检测性。 下面讨论如何<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#EnablingDiscoverability" target="_blank" rel="noopener">启用可检测性</a>。</p></blockquote><h1 id="查询配对的设备"><a href="#查询配对的设备" class="headerlink" title="查询配对的设备"></a>查询配对的设备</h1><p>在执行设备发现之前，有必要查询已配对的设备集，以了解所需的设备是否处于已知状态。 为此，请调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#getBondedDevices(" target="_blank" rel="noopener">getBondedDevices()</a>)。 这将返回表示已配对设备的一组 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html" target="_blank" rel="noopener">BluetoothDevice</a>。 例如，您可以查询所有已配对设备，然后使用 ArrayAdapter 向用户显示每台设备的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();</span><br><span class="line"><span class="comment">// If there are paired devices</span></span><br><span class="line"><span class="keyword">if</span> (pairedDevices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Loop through paired devices</span></span><br><span class="line">    <span class="keyword">for</span> (BluetoothDevice device : pairedDevices) &#123;</span><br><span class="line">        <span class="comment">// Add the name and address to an array adapter to show in a ListView</span></span><br><span class="line">        mArrayAdapter.add(device.getName() + <span class="string">"\n"</span> + device.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要发起连接，<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html" target="_blank" rel="noopener">BluetoothDevice</a> 对象仅仅需要提供 MAC 地址。 在此示例中，它将保存为显示给用户的 ArrayAdapter 的一部分。 之后可提取该 MAC 地址，以便发起连接。 您可以在有关<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#ConnectingDevices" target="_blank" rel="noopener">连接设备</a>的部分详细了解如何创建连接。</p><h1 id="发现设备"><a href="#发现设备" class="headerlink" title="发现设备"></a>发现设备</h1><p>要开始发现设备，只需调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#startDiscovery(" target="_blank" rel="noopener">startDiscovery()</a>)。该进程为异步进程，并且该方法会立即返回一个布尔值，指示是否已成功启动发现操作。 发现进程通常包含约 12 秒钟的查询扫描，之后对每台发现的设备进行页面扫描，以检索其蓝牙名称。</p><p>您的应用必须针对 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html#ACTION_FOUND" target="_blank" rel="noopener">ACTION_FOUND</a> Intent 注册一个 BroadcastReceiver，以便接收每台发现的设备的相关信息。 针对每台设备，系统将会广播 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html#ACTION_FOUND" target="_blank" rel="noopener">ACTION_FOUND</a> Intent。此 Intent 将携带额外字段 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html#EXTRA_DEVICE" target="_blank" rel="noopener">EXTRA_DEVICE</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html#EXTRA_CLASS" target="_blank" rel="noopener">EXTRA_CLASS</a>，二者分别包含 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html" target="_blank" rel="noopener">BluetoothDevice</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothClass.html" target="_blank" rel="noopener">BluetoothClass</a>。 例如，下面说明了在发现设备时如何注册以处理广播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a BroadcastReceiver for ACTION_FOUND</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        <span class="comment">// When discovery finds a device</span></span><br><span class="line">        <span class="keyword">if</span> (BluetoothDevice.ACTION_FOUND.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// Get the BluetoothDevice object from the Intent</span></span><br><span class="line">            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">            <span class="comment">// Add the name and address to an array adapter to show in a ListView</span></span><br><span class="line">            mArrayAdapter.add(device.getName() + <span class="string">"\n"</span> + device.getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Register the BroadcastReceiver</span></span><br><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">registerReceiver(mReceiver, filter); <span class="comment">// Don't forget to unregister during onDestroy</span></span><br></pre></td></tr></table></figure><p>要发起连接，<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothDevice.html" target="_blank" rel="noopener">BluetoothDevice</a> 对象仅仅需要提供 MAC 地址。 在此示例中，它将保存为显示给用户的 ArrayAdapter 的一部分。 之后可提取该 MAC 地址，以便发起连接。 您可以在有关<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#ConnectingDevices" target="_blank" rel="noopener">连接设备</a>的部分详细了解如何创建连接。</p><blockquote><p><strong>注意</strong>：执行设备发现对于蓝牙适配器而言是一个非常繁重的操作过程，并且会消耗大量资源。 在找到要连接的设备后，确保始终使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#cancelDiscovery(" target="_blank" rel="noopener">cancelDiscovery()</a>) 停止发现，然后再尝试连接。 此外，如果您已经保持与某台设备的连接，那么执行发现操作可能会大幅减少可用于该连接的带宽，因此不应该在处于连接状态时执行发现操作。</p></blockquote><h1 id="启用可检测性"><a href="#启用可检测性" class="headerlink" title="启用可检测性"></a>启用可检测性</h1><p>如果您希望将本地设备设为可被其他设备检测到，请使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#ACTION_REQUEST_DISCOVERABLE" target="_blank" rel="noopener">ACTION_REQUEST_DISCOVERABLE</a> 操作 Intent 调用 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#startActivityForResult(android.content.Intent, int" target="_blank" rel="noopener">startActivityForResult(Intent, int)</a>)。 这将通过系统设置发出启用可检测到模式的请求（无需停止您的应用）。 默认情况下，设备将变为可检测到并持续 120 秒钟。 您可以通过添加 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#EXTRA_DISCOVERABLE_DURATION" target="_blank" rel="noopener">EXTRA_DISCOVERABLE_DURATION</a> Intent Extra 来定义不同的持续时间。 应用可以设置的最大持续时间为 3600 秒，值为 0 则表示设备始终可检测到。 任何小于 0 或大于 3600 的值都会自动设为 120 秒。 例如，以下片段会将持续时间设为 300 秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent discoverableIntent = <span class="keyword">new</span></span><br><span class="line">Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);</span><br><span class="line">discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, <span class="number">300</span>);</span><br><span class="line">startActivity(discoverableIntent);</span><br></pre></td></tr></table></figure><p><img src="/media/15138419867174.png" alt=""><br>图 2：启用可检测性对话框。</p><p>如图 2 所示，将显示对话框，请求用户允许将设备设为可检测到。如果用户响应“Yes”，则设备将变为可检测到并持续指定的时间量。 然后，您的 Activity 将会收到对 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#onActivityResult(int, int, android.content.Intent" target="_blank" rel="noopener">onActivityResult</a>)() 回调的调用，其结果代码等于设备可检测到的持续时间。 如果用户响应“No”或出现错误，结果代码将为 <a href="https://developer.android.google.cn/reference/android/app/Activity.html#RESULT_CANCELED" target="_blank" rel="noopener">RESULT_CANCELED</a>。</p><blockquote><p><strong>注</strong>：如果尚未在设备上启用蓝牙，则启用设备可检测性将会自动启用蓝牙。</p></blockquote><p>设备将在分配的时间内以静默方式保持可检测到模式。如果您希望在可检测到模式发生变化时收到通知，您可以针对 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#ACTION_SCAN_MODE_CHANGED" target="_blank" rel="noopener">ACTION_SCAN_MODE_CHANGED</a> Intent 注册 BroadcastReceiver。 它将包含额外字段 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#EXTRA_SCAN_MODE" target="_blank" rel="noopener">EXTRA_SCAN_MODE</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#EXTRA_PREVIOUS_SCAN_MODE" target="_blank" rel="noopener">EXTRA_PREVIOUS_SCAN_MODE</a>，二者分别告知您新的和旧的扫描模式。 每个字段可能的值包括 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#SCAN_MODE_CONNECTABLE_DISCOVERABLE" target="_blank" rel="noopener">SCAN_MODE_CONNECTABLE_DISCOVERABLE</a>、 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#SCAN_MODE_CONNECTABLE" target="_blank" rel="noopener">SCAN_MODE_CONNECTABLE</a> 或 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#SCAN_MODE_NONE" target="_blank" rel="noopener">SCAN_MODE_NONE</a>，这些值分别指示设备处于可检测到模式、未处于可检测到模式但仍能接收连接，或未处于可检测到模式并且无法接收连接。</p><p>如果您将要发起到远程设备的连接，则无需启用设备可检测性。 仅当您希望您的应用托管将用于接受传入连接的服务器套接字时，才有必要启用可检测性，因为远程设备必须能够发现该设备，然后才能发起连接。</p><h1 id="连接设备"><a href="#连接设备" class="headerlink" title="连接设备"></a>连接设备</h1><p>要在两台设备上的应用之间创建连接，必须同时实现服务器端和客户端机制，因为其中一台设备必须开放服务器套接字，而另一台设备必须发起连接（使用服务器设备的 MAC 地址发起连接）。 当服务器和客户端在同一 RFCOMM 通道上分别拥有已连接的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 时，二者将被视为彼此连接。 这种情况下，每台设备都能获得输入和输出流式传输，并且可以开始传输数据，在有关<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#ManagingAConnection" target="_blank" rel="noopener">管理连接</a>的部分将会讨论这一主题。 本部分介绍如何在两台设备之间发起连接。</p><p>服务器设备和客户端设备分别以不同的方法获得需要的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。服务器将在传入连接被接受时收到套接字。 客户端将在其打开到服务器的 RFCOMM 通道时收到该套接字。</p><p><img src="/media/15138420406140.png" alt=""></p><p>图 3：蓝牙配对对话框。</p><p>一种实现技术是自动将每台设备准备为一个服务器，从而使每台设备开放一个服务器套接字并侦听连接。然后任一设备可以发起与另一台设备的连接，并成为客户端。 或者，其中一台设备可显式“托管”连接并按需开放一个服务器套接字，而另一台设备则直接发起连接。</p><blockquote><p><strong>注</strong>：如果两台设备之前尚未配对，则在连接过程中，Android 框架会自动向用户显示配对请求通知或对话框（如图 3 所示）。因此，在尝试连接设备时，您的应用无需担心设备是否已配对。 您的 RFCOMM 连接尝试将被阻塞，直至用户成功完成配对或配对失败（包括用户拒绝配对、配对失败或超时）。</p></blockquote><h1 id="连接为服务器"><a href="#连接为服务器" class="headerlink" title="连接为服务器"></a>连接为服务器</h1><p>当您需要连接两台设备时，其中一台设备必须通过保持开放的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 来充当服务器。 服务器套接字的用途是侦听传入的连接请求，并在接受一个请求后提供已连接的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。 从 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 后，可以（并且应该）舍弃 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a>，除非您需要接受更多连接。<br>以下是设置服务器套接字并接受连接的基本过程：</p><ol><li><p>通过调用</p><p> <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#listenUsingRfcommWithServiceRecord(java.lang.String, java.util.UUID" target="_blank" rel="noopener">listenUsingRfcommWithServiceRecord(String, UUID) </a>)获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a>。<br> 该字符串是您的服务的可识别名称，系统会自动将其写入到设备上的新服务发现协议 (SDP) 数据库条目（可使用任意名称，也可直接使用您的应用名称）。 UUID 也包含在 SDP 条目中，并且将作为与客户端设备的连接协议的基础。 也就是说，当客户端尝试连接此设备时，它会携带能够唯一标识其想要连接的服务的 UUID。 两个 UUID 必须匹配，在下一步中，连接才会被接受</p></li><li><p>通过调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#accept(" target="_blank" rel="noopener">accept()</a>) 开始侦听连接请求。</p><p> 这是一个阻塞调用。它将在连接被接受或发生异常时返回。 仅当远程设备发送的连接请求中所包含的 UUID 与向此侦听服务器套接字注册的 UUID 相匹配时，连接才会被接受。 操作成功后，<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#accept(" target="_blank" rel="noopener">accept()</a>) 将会返回已连接的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。</p></li><li><p>除非您想要接受更多连接，否则请调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#close(" target="_blank" rel="noopener">close()</a>)。</p><p> 这将释放服务器套接字及其所有资源，但不会关闭 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#accept(" target="_blank" rel="noopener">accept()</a>) 所返回的已连接的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。 与 TCP/IP 不同，RFCOMM 一次只允许每个通道有一个已连接的客户端，因此大多数情况下，在接受已连接的套接字后立即在 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 上调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#close(" target="_blank" rel="noopener">close()</a>) 是行得通的。</p></li></ol><p><a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#accept(" target="_blank" rel="noopener">accept()</a>) 调用不应在主 Activity UI 线程中执行，因为它是阻塞调用，并会阻止与应用的任何其他交互。 在您的应用所管理的新线程中使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 或 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 完成所有工作，这通常是一种行之有效的做法。 要终止 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#accept(" target="_blank" rel="noopener">accept()</a>) 等被阻塞的调用，请通过另一个线程在 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a>（或 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>）上调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#close(" target="_blank" rel="noopener">close()</a>)，被阻塞的调用将会立即返回。 请注意，<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 或 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 中的所有方法都是线程安全的方法。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一个用于接受传入连接的服务器组件的简化线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BluetoothServerSocket mmServerSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcceptThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a temporary object that is later assigned to mmServerSocket,</span></span><br><span class="line">        <span class="comment">// because mmServerSocket is final</span></span><br><span class="line">        BluetoothServerSocket tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MY_UUID is the app's UUID string, also used by the client code</span></span><br><span class="line">            tmp = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">        mmServerSocket = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BluetoothSocket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Keep listening until exception occurs or a socket is returned</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = mmServerSocket.accept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If a connection was accepted</span></span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Do work to manage the connection (in a separate thread)</span></span><br><span class="line">                manageConnectedSocket(socket);</span><br><span class="line">                mmServerSocket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Will cancel the listening socket, and cause the thread to finish */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mmServerSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，只需要一个传入连接，因此在接受连接并获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 之后，应用会立即将获取的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 发送到单独的线程，关闭 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 并中断循环。</p><p>请注意，当 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#accept(" target="_blank" rel="noopener">accept()</a>) 返回 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 时，表示套接字已连接好，因此您不应该像在客户端那样调用 connect()。</p><p>manageConnectedSocket() 是应用中的虚构方法，它将启动用于传输数据的线程，在有关管理连接的部分将会讨论这一主题。</p><p>在完成传入连接的侦听后，通常应立即关闭您的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a>。 在此示例中，获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 后立即调用 close()。 您也可能希望在您的线程中提供一个公共方法，以便在需要停止侦听服务器套接字时关闭私有 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。</p><h1 id="连接为客户端"><a href="#连接为客户端" class="headerlink" title="连接为客户端"></a>连接为客户端</h1><p>要发起与远程设备（保持开放的服务器套接字的设备）的连接，必须首先获取表示该远程设备的 BluetoothDevice 对象。（在前面有关查找设备的部分介绍了如何获取 BluetoothDevice）。 然后必须使用 BluetoothDevice 来获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 并发起连接。</p><p>以下是基本过程：</p><ol><li><p>使用 BluetoothDevice，通过调用 createRfcommSocketToServiceRecord(UUID) 获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。</p><p> 这将初始化将要连接到 BluetoothDevice 的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。 此处传递的 UUID 必须与服务器设备在使用 listenUsingRfcommWithServiceRecord(String, UUID) 开放其 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html" target="_blank" rel="noopener">BluetoothServerSocket</a> 时所用的 UUID 相匹配。 要使用相同的 UUID，只需将该 UUID 字符串以硬编码方式编入应用，然后通过服务器代码和客户端代码引用该字符串。</p></li><li><p>通过调用 connect() 发起连接。</p><p> 执行此调用时，系统将会在远程设备上执行 SDP 查找，以便匹配 UUID。 如果查找成功并且远程设备接受了该连接，它将共享 RFCOMM 通道以便在连接期间使用，并且 connect() 将会返回。 此方法为阻塞调用。 如果由于任何原因连接失败或 connect() 方法超时（大约 12 秒之后），它将会引发异常。</p></li></ol><p>由于 connect() 为阻塞调用，因此该连接过程应始终在主 Activity 线程以外的线程中执行。</p><blockquote><p><strong>注</strong>：在调用 connect() 时，应始终确保设备未在执行设备发现。 如果正在进行发现操作，则会大幅降低连接尝试的速度，并增加连接失败的可能性。</p></blockquote><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BluetoothSocket mmSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BluetoothDevice mmDevice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectThread</span><span class="params">(BluetoothDevice device)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a temporary object that is later assigned to mmSocket,</span></span><br><span class="line">        <span class="comment">// because mmSocket is final</span></span><br><span class="line">        BluetoothSocket tmp = <span class="keyword">null</span>;</span><br><span class="line">        mmDevice = device;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get a BluetoothSocket to connect with the given BluetoothDevice</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MY_UUID is the app's UUID string, also used by the server code</span></span><br><span class="line">            tmp = device.createRfcommSocketToServiceRecord(MY_UUID);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">        mmSocket = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Cancel discovery because it will slow down the connection</span></span><br><span class="line">        mBluetoothAdapter.cancelDiscovery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Connect the device through the socket. This will block</span></span><br><span class="line">            <span class="comment">// until it succeeds or throws an exception</span></span><br><span class="line">            mmSocket.connect();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException connectException) &#123;</span><br><span class="line">            <span class="comment">// Unable to connect; close the socket and get out</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mmSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException closeException) &#123; &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do work to manage the connection (in a separate thread)</span></span><br><span class="line">        manageConnectedSocket(mmSocket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Will cancel an in-progress connection, and close the socket */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mmSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在建立连接之前会调用 cancelDiscovery()。 在进行连接之前应始终执行此调用，而且调用时无需实际检查其是否正在运行（但如果您确实想要执行检查，请调用 isDiscovering()）。</p><p>manageConnectedSocket() 是应用中的虚构方法，它将启动用于传输数据的线程，在有关管理连接的部分将会讨论这一主题。</p><p>在完成 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 后，应始终调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothServerSocket.html#close(" target="_blank" rel="noopener">close()</a>) 以执行清理操作。这样做会立即关闭已连接的套接字并清理所有内部资源。</p><h1 id="管理连接"><a href="#管理连接" class="headerlink" title="管理连接"></a>管理连接</h1><p>在成功连接两台（或更多台）设备后，每台设备都会有一个已连接的 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>。 这一点非常有趣，因为这表示您可以在设备之间共享数据。 利用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a>，传输任意数据的一般过程非常简单：</p><ol><li><p>获取 <a href="https://developer.android.google.cn/reference/java/io/InputStream.html" target="_blank" rel="noopener">InputStream</a> 和 <a href="https://developer.android.google.cn/reference/java/io/OutputStream.html" target="_blank" rel="noopener">OutputStream</a>，二者分别通过套接字以及 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html#getInputStream(" target="_blank" rel="noopener">getInputStream()</a>) 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html#getOutputStream(" target="_blank" rel="noopener">getOutputStream()</a>) 来处理数据传输。</p></li><li><p>使用 <a href="https://developer.android.google.cn/reference/java/io/InputStream.html#read(byte[]" target="_blank" rel="noopener">read(byte[])</a>) 和 <a href="https://developer.android.google.cn/reference/java/io/OutputStream.html#write(byte[]" target="_blank" rel="noopener">write(byte[])</a>) 读取数据并写入到流式传输。<br>就这么简单。</p></li></ol><p>当然，还需要考虑实现细节。首要的是，应该为所有流式传输读取和写入操作使用专门的线程。 这一点很重要，因为 read(byte[]) 和 write(byte[]) 方法都是阻塞调用。read(byte[]) 将会阻塞，直至从流式传输中读取内容。write(byte[]) 通常不会阻塞，但如果远程设备没有足够快地调用 read(byte[])，并且中间缓冲区已满，则其可能会保持阻塞状态以实现流量控制。因此，线程中的主循环应专门用于读取 <a href="https://developer.android.google.cn/reference/java/io/InputStream.html" target="_blank" rel="noopener">InputStream</a>。 可使用线程中单独的公共方法来发起对 <a href="https://developer.android.google.cn/reference/java/io/OutputStream.html" target="_blank" rel="noopener">OutputStream</a> 的写入操作。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>以下是可能的显示内容示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectedThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BluetoothSocket mmSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream mmInStream;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OutputStream mmOutStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectedThread</span><span class="params">(BluetoothSocket socket)</span> </span>&#123;</span><br><span class="line">        mmSocket = socket;</span><br><span class="line">        InputStream tmpIn = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream tmpOut = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the input and output streams, using temp objects because</span></span><br><span class="line">        <span class="comment">// member streams are final</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tmpIn = socket.getInputStream();</span><br><span class="line">            tmpOut = socket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        mmInStream = tmpIn;</span><br><span class="line">        mmOutStream = tmpOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  <span class="comment">// buffer store for the stream</span></span><br><span class="line">        <span class="keyword">int</span> bytes; <span class="comment">// bytes returned from read()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep listening to the InputStream until an exception occurs</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Read from the InputStream</span></span><br><span class="line">                bytes = mmInStream.read(buffer);</span><br><span class="line">                <span class="comment">// Send the obtained bytes to the UI activity</span></span><br><span class="line">                mHandler.obtainMessage(MESSAGE_READ, bytes, -<span class="number">1</span>, buffer)</span><br><span class="line">                        .sendToTarget();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call this from the main activity to send data to the remote device */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mmOutStream.write(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call this from the main activity to shutdown the connection */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mmSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数获取必要的流式传输，并且一旦执行，线程将会等待通过 InputStream 传入的数据。 当 read(byte[]) 返回流式传输中的字节时，将使用来自父类的成员处理程序将数据发送到主 Activity。 然后该方法返回并等待流式传输提供更多字节。</p><p>发送传出数据不外乎从主 Activity 调用线程的 write() 方法，并传入要发送的字节。 然后，此方法直接调用 write(byte[])，将数据发送到远程设备。</p><p>线程的 cancel() 方法很重要，它能通过关闭 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothSocket.html" target="_blank" rel="noopener">BluetoothSocket</a> 随时终止连接。当您结束蓝牙连接的使用时，应始终调用此方法。</p><p>有关使用 Bluetooth API 的演示，请参阅蓝牙聊天示例应用。</p><h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><p>从 Android 3.0 开始，Bluetooth API 便支持使用蓝牙配置文件。 蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。 免提配置文件便是一个示例。 对于连接到无线耳机的手机，两台设备都必须支持免提配置文件。</p><p>您可以实现接口 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.html" target="_blank" rel="noopener">BluetoothProfile</a>，通过写入自己的类来支持特定的蓝牙配置文件。 Android Bluetooth API 提供了以下蓝牙配置文件的实现：</p><ul><li><p><strong>耳机</strong>。耳机配置文件提供了蓝牙耳机支持，以便与手机配合使用。 Android 提供了 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHeadset.html" target="_blank" rel="noopener">BluetoothHeadset</a> 类，它是用于通过进程间通信 (<a href="https://developer.android.google.cn/guide/components/processes-and-threads.html#IPC" target="_blank" rel="noopener">IPC</a>) 来控制蓝牙耳机服务的代理。 这包括蓝牙耳机和免提（1.5 版）配置文件。 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHeadset.html" target="_blank" rel="noopener">BluetoothHeadset</a> 类包含 AT 命令支持。 有关此主题的详细讨论，请参阅供应商特定的 AT 命令</p></li><li><p><strong>A2DP</strong>。高级音频分发配置文件 (A2DP) 定义了高质量音频如何通过蓝牙连接和流式传输，从一个设备传输到另一个设备。 Android 提供了 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothA2dp.html" target="_blank" rel="noopener">BluetoothA2dp</a> 类，它是用于通过 IPC 来控制蓝牙 A2DP 服务的代理。</p></li><li><p><strong>健康设备</strong>。Android 4.0（API 级别 14）引入了对蓝牙健康设备配置文件 (HDP) 的支持。 这允许您创建应用，使用蓝牙与支持蓝牙功能的健康设备进行通信，例如心率监测仪、血糖仪、温度计、台秤等等。 有关支持的设备列表及其相应的设备数据专业化代码，请参阅 <a href="http://www.bluetooth.org" target="_blank" rel="noopener">www.bluetooth.org</a> 上的蓝牙分配编号。 请注意，这些值在 ISO/IEEE 11073-20601 [7] 规范的“命名法规附录”中也被称为 MDC_DEV_SPEC_PROFILE_*。 有关 HDP 的详细讨论，请参阅<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#HDP" target="_blank" rel="noopener">健康设备配置文件</a>。</p></li></ul><p>以下是使用配置文件的基本步骤：</p><ol><li>获取默认适配器（请参阅<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#SettingUp" target="_blank" rel="noopener">设置蓝牙</a>）。</li><li>使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#getProfileProxy(android.content.Context, android.bluetooth.BluetoothProfile.ServiceListener, int" target="_blank" rel="noopener">getProfileProxy()</a>) 建立到配置文件所关联的配置文件代理对象的连接。在以下示例中，配置文件代理对象是一个 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHeadset.html" target="_blank" rel="noopener">BluetoothHeadset</a> 的实例。</li><li>设置 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.ServiceListener.html" target="_blank" rel="noopener">BluetoothProfile.ServiceListener</a>。此侦听程序会在 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.html" target="_blank" rel="noopener">BluetoothProfile</a> IPC 客户端连接到服务或断开服务连接时向其发送通知。</li><li>在 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.ServiceListener.html#onServiceConnected(int, android.bluetooth.BluetoothProfile" target="_blank" rel="noopener">onServiceConnected()</a>) 中，获取配置文件代理对象的句柄。</li><li>获得配置文件代理对象后，可以立即将其用于监视连接状态和执行其他与该配置文件相关的操作。</li></ol><p>例如，以下代码片段显示了如何连接到 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHeadset.html" target="_blank" rel="noopener">BluetoothHeadset</a> 代理对象，以便能够控制耳机配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BluetoothHeadset mBluetoothHeadset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the default adapter</span></span><br><span class="line">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Establish connection to the proxy.</span></span><br><span class="line">mBluetoothAdapter.getProfileProxy(context, mProfileListener, BluetoothProfile.HEADSET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BluetoothProfile.ServiceListener mProfileListener = <span class="keyword">new</span> BluetoothProfile.ServiceListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(<span class="keyword">int</span> profile, BluetoothProfile proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (profile == BluetoothProfile.HEADSET) &#123;</span><br><span class="line">            mBluetoothHeadset = (BluetoothHeadset) proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(<span class="keyword">int</span> profile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (profile == BluetoothProfile.HEADSET) &#123;</span><br><span class="line">            mBluetoothHeadset = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... call functions on mBluetoothHeadset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Close proxy connection after use.</span></span><br><span class="line">mBluetoothAdapter.closeProfileProxy(mBluetoothHeadset);</span><br></pre></td></tr></table></figure><h1 id="供应商特定的-AT-命令"><a href="#供应商特定的-AT-命令" class="headerlink" title="供应商特定的 AT 命令"></a>供应商特定的 AT 命令</h1><p>从 Android 3.0 开始，应用可以注册接收耳机所发送的预定义的供应商特定 AT 命令的系统广播（例如 Plantronics +XEVENT 命令）。 例如，应用可以接收指示所连接设备的电池电量的广播，并根据需要通知用户或采取其他操作。 为 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHeadset.html#ACTION_VENDOR_SPECIFIC_HEADSET_EVENT" target="_blank" rel="noopener">ACTION_VENDOR_SPECIFIC_HEADSET_EVENT</a> intent 创建广播接收器，以处理耳机的供应商特定 AT 命令。</p><h1 id="健康设备配置文件"><a href="#健康设备配置文件" class="headerlink" title="健康设备配置文件"></a>健康设备配置文件</h1><p>Android 4.0（API 级别 14）引入了对蓝牙健康设备配置文件 (HDP) 的支持。 这允许您创建应用，使用蓝牙与支持蓝牙功能的健康设备进行通信，例如心率监测仪、血糖仪、温度计、台秤等等。 Bluetooth Health API 包括类 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealth.html" target="_blank" rel="noopener">BluetoothHealth</a>、<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthCallback.html" target="_blank" rel="noopener">BluetoothHealthCallback</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthAppConfiguration.html" target="_blank" rel="noopener">BluetoothHealthAppConfiguration</a>，在<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#TheBasicsw" target="_blank" rel="noopener">基础知识</a>部分介绍了这些类。</p><p>在使用 Bluetooth Health API 时，了解以下关键 HDP 概念很有帮助：</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>源设备<span class="Apple-tab-span" style="white-space:pre"></span></td><td>在 HDP 中定义的角色。源设备是将医疗数据传输到 Android 手机或平板电脑等智能设备的健康设备（体重秤、血糖仪、温度计等）。</td></tr><tr><td>汇集设备</td><td>在 HDP 中定义的角色。在 HDP 中，汇集设备是接收医疗数据的智能设备。 在 Android HDP 应用中，汇集设备表示为 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthAppConfiguration.html" target="_blank" rel="noopener">BluetoothHealthAppConfiguration</a> 对象。</td></tr><tr><td>注册</td><td>指的是注册特定健康设备的汇集设备。</td></tr><tr><td>连接</td><td>指的是开放健康设备与 Android 手机或平板电脑等智能设备之间的通道。</td></tr></tbody></table><h1 id="创建-HDP-应用"><a href="#创建-HDP-应用" class="headerlink" title="创建 HDP 应用"></a>创建 HDP 应用</h1><p>以下是创建 Android HDP 应用所涉及的基本步骤：</p><ol><li><p>获取 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealth.html" target="_blank" rel="noopener">BluetoothHealth</a> 代理对象的引用。</p><p> 与常规耳机和 A2DP 配置文件设备相似，您必须使用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.ServiceListener.html" target="_blank" rel="noopener">BluetoothProfile.ServiceListener</a> 和 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothProfile.html#HEALTH" target="_blank" rel="noopener">HEALTH</a> 配置文件类型来调用 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothAdapter.html#getProfileProxy(android.content.Context, android.bluetooth.BluetoothProfile.ServiceListener, int" target="_blank" rel="noopener">getProfileProxy()</a>)，以便与配置文件代理对象建立连接。</p></li><li><p>创建 <a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthCallback.html" target="_blank" rel="noopener">BluetoothHealthCallback</a> 并注册充当健康汇集设备的应用配置 (<a href="https://developer.android.google.cn/reference/android/bluetooth/BluetoothHealthAppConfiguration.html" target="_blank" rel="noopener">BluetoothHealthAppConfiguration</a>)。</p></li><li><p>建立到健康设备的连接。一些设备将会发起该连接。 对于这类设备，无需执行该步骤。</p></li><li><p>成功连接到健康设备后，使用文件描述符对健康设备执行读/写操作。接收的数据需要使用实现了 IEEE 11073-xxxxx 规范的健康管理器进行解释。</p></li><li><p>完成后，关闭健康通道并取消注册该应用。该通道在长期闲置时也会关闭。</p></li></ol><p>有关描述上述步骤的完整代码示例，请参阅<a href="https://developer.android.google.cn/resources/samples/BluetoothHDP/index.html" target="_blank" rel="noopener">蓝牙 HDP（健康设备配置文件）</a>。</p><p>原文地址:<a href="https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#ManagingAConnection" target="_blank" rel="noopener">https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html#ManagingAConnection</a></p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/639eaf27.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android低功耗蓝牙</title>
      <link>https://mliyuanbiao.github.io/post/647d650a.html</link>
      <guid>https://mliyuanbiao.github.io/post/647d650a.html</guid>
      <pubDate>Thu, 21 Dec 2017 06:58:17 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;关键术语和概念&quot;&gt;&lt;a href=&quot;#关键术语和概念&quot; class=&quot;headerlink&quot; title=&quot;关键术语和概念&quot;&gt;&lt;/a&gt;关键术语和概念&lt;/h1&gt;&lt;h2 id=&quot;下面是一些BLE关键术语和概念的摘要&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="关键术语和概念"><a href="#关键术语和概念" class="headerlink" title="关键术语和概念"></a>关键术语和概念</h1><h2 id="下面是一些BLE关键术语和概念的摘要"><a href="#下面是一些BLE关键术语和概念的摘要" class="headerlink" title="下面是一些BLE关键术语和概念的摘要"></a>下面是一些BLE关键术语和概念的摘要</h2><ul><li>Generic Attribute Profile（GATT）：GATT profile是一种关于发送和接收简短数据片段的一般规范，这种简短数据片段例如在BLE的连接上众所周知的“attribute（属性）”等。当前所有低功耗应用程序的profile都基于GATT。另外，蓝牙技术联盟（Bluetooth SIG）已经为很多BLE设备定义了profile。profile就是一种在指定的应用程序中定义设备如何工作的规范。注意，一台设备可以实现多个profile。例如，一台设备可以包含心率监视器和电池电量探测器。</li><li>Attribute Protocol（ATT，属性协议）：GATT构建在ATT的基础之上，因此也总被成为GATT/ATT。ATT针对BLE设备的运行进行了优化。为此，它会尽可能的使用更少的字节数据。每一个属性都通过UUID来唯一确定。UUID就是一个标准128位格式的字符串ID，用于唯一确定一个信息。属性通过ATT协议格式化为characteristics和services后进行传输。</li><li>Characteristic：一个characteristic中包含一个值，以及0个或多个用于描述characteristic值的descriptor。可以将characteristic认为是一种类型，类似于一个类。</li><li>Descriptor：Descriptor（描述符）中定义的属性用于描述一个characteristic值。例如，一个descriptor可以为一个characteristic的值指定一个在可接受范围内的可读性描述，或者为一个characteristic的值指定一个计量单位。</li><li>Service：一个service是一个characteristic的集合。例如，你可以持有一个名为“心率监视器”的service，它包含的characteristic例如“心率测量”。你可以在bluetooth.org上找到一系列基于GATT的profile和service。</li></ul><h2 id="角色和职能"><a href="#角色和职能" class="headerlink" title="角色和职能"></a>角色和职能</h2><p>以下是一台Android设备与BLE设备交互时的一些适用角色和职能：</p><ul><li><p>中央设备和外围设备。这适用于BLE自身的连接。担任中央设备角色的设备负责扫描和搜索广告，担任外围设备的角色负责发送广告。</p></li><li><p>GATT服务端和GATT客户端。这取决于两台设备在建立连接后如何互相通信。</p></li></ul><p>为了理解这之间的区别，想象你有一台Android手机和一台BLE设备作为活动追踪器。手机将担任中央设备角色；活动追踪器将担任外围设备角色（你需要具备两种角色才能建立一个BLE连接，两者都担任外围设备角色不能互相通信，同样两者都担任中央设备角色也不能互相通信）。</p><p>一旦手机和活动追踪器建立连接，它们就可以互相传输GATT媒体数据。根据它们传输的数据，其中一方需要担任服务端的角色。例如，如果活动追踪器想要发送传感器数据给手机，活动追踪器就需要担任服务端的角色。如果活动追踪器想要接收手机的数据，手机就需要担任服务端的角色。</p><p>在本片文档的例子中，Android应用程序（运行在Android设备上）是GATT客户端。应用程序从GATT服务端获取数据，这个服务端由支持Heart Rate Profile的BLE心率监视器设备担任。但是你可以交替让你的Android应用程序扮演GATT服务端的角色。具体参考<a href="http://developer.android.com/reference/android/bluetooth/BluetoothGattServer.html" target="_blank" rel="noopener">BluetoothGattService</a>。</p><h1 id="BLE-Permissions（BLE权限）"><a href="#BLE-Permissions（BLE权限）" class="headerlink" title="BLE Permissions（BLE权限）"></a>BLE Permissions（BLE权限）</h1><p>为了在你的应用程序中使用Bluetooth的功能，你必须声明android.permission.BLUETOOTH权限。你需要这个权限来执行一些蓝牙通信的操作，例如请求链接，接受连接，还有传输数据。</p><p>如果你想让你的应用程序进行设备扫描或者管理蓝牙设置，你必须同时声明android.permission.BLUETOOTH_ADMIN权限。注意，如果你使用BLUETOOTH_ADMIN权限，你必须同时声明BLUETOOTH权限。</p><p>在你的应用程序manifest文件中声明蓝牙权限，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想声明你的应用程序只能在支持BLE的设备上运行，可以将下面声明包含进你的应用程序manifest文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.bluetooth_le"</span> <span class="attr">android:required</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然而，如果你想让你的应用程序也能够在不支持BLE的设备上运行，你就应该将上面标签中的属性设置为<code>required=&quot;false&quot;</code>。然后在运行的过程中使用<code>PackageManager.hasSystemFeature()</code>方法来判断设备是否支持BLE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下面的方法来确定设备是否支持BLE, 然后你可以选择禁用BLE的功能  </span></span><br><span class="line"><span class="keyword">if</span> (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123;  </span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();  </span><br><span class="line">    finish();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Setting-Up-BLE（设置BLE）"><a href="#Setting-Up-BLE（设置BLE）" class="headerlink" title="Setting Up BLE（设置BLE）"></a>Setting Up BLE（设置BLE）</h1><p>在你的应用程序通过BLE进行通信之前，你需要确认设备是否支持BLE。如果支持，还要再确认是否已经启用。注意这个检查步骤只有在<code>&lt;uses-festure.../&gt;</code>设置为<code>false</code>的情况下才需要执行。</p><p>如果不支持BLE，你应该优雅的禁止一些使用BLE的功能。如果支持BLE，但是目前禁用了，那么你需要在不离开你的应用程序状态下，请求用户启用蓝牙用能。这个过程需要使用BluetoothAdapter，分两个步骤完成：</p><h2 id="获取BluetoothAdapter"><a href="#获取BluetoothAdapter" class="headerlink" title="获取BluetoothAdapter"></a>获取BluetoothAdapter</h2><p>基本上所有使用蓝牙的activity都需要BluetoothAdapter。BluetoothAdapter代表了设备本身的蓝牙适配器（蓝牙发送接收器）。在整个系统中有一个BluetoothAdapter对象，你的应用程序可以使用这个对象进行交互。下面的代码片段展示了如果获取这个适配器。注意下面的这种方法使用getSystemService()方法来获取一个BluetoothManager实例，之后再通过BluetoothManager获取BluetoothAdapter。Android 4.3（API Level 18）才开始支持BluetoothManager：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化蓝牙适配器.  </span></span><br><span class="line"><span class="keyword">final</span> BluetoothManager bluetoothManager =  </span><br><span class="line">        (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);  </span><br><span class="line">mBluetoothAdapter = bluetoothManager.getAdapter();</span><br></pre></td></tr></table></figure><h2 id="启用蓝牙"><a href="#启用蓝牙" class="headerlink" title="启用蓝牙"></a>启用蓝牙</h2><p>下一步，你需要确保蓝牙已经启动。调用<code>isEnable()</code>方法来检查蓝牙当前是否已经启用。如果方法返回false，说明蓝牙被禁用了。下面的代码片段中检查蓝牙是否已经启用。如果没有启用，代码片段会显示一个错误提示用户去设置中启用蓝牙：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;  </span><br><span class="line">...  </span><br><span class="line"><span class="comment">// 确认设备支持蓝牙并且已经启用. 如果没有,  </span></span><br><span class="line"><span class="comment">// 显示一个对话框要求用户授权启用蓝牙.  </span></span><br><span class="line"><span class="keyword">if</span> (mBluetoothAdapter == <span class="keyword">null</span> || !mBluetoothAdapter.isEnabled()) &#123;  </span><br><span class="line">    Intent enableBtIntent = <span class="keyword">new</span> Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);  </span><br><span class="line">    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Finding-BLE-Devices（搜索BLE设备）"><a href="#Finding-BLE-Devices（搜索BLE设备）" class="headerlink" title="Finding BLE Devices（搜索BLE设备）"></a>Finding BLE Devices（搜索BLE设备）</h1><p>搜索BLE设备，你可以使用startLeScan()方法。这个方法需要一个BluetoothAdapter.LeScanCallback对象作为参数。你必须实现这个callback接口，因为扫描的结果会通过这个接口返回。由于搜索设备是比较耗电的操作，你应该遵循以下指南使用：</p><ul><li><p>一旦你找到目标设备，应该马上停止搜索。</p></li><li><p>不要死循环搜索，并设置搜索的最长时间。一台以前可以访问的设备可能已经移出了可检测范围，继续扫描只会消耗电量。</p></li></ul><p>下面的代码片段展示了如何开始和停止搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描和显示可访问BLE设备的Activity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceScanActivity</span> <span class="keyword">extends</span> <span class="title">ListActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mScanning;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10秒钟后停止扫描.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SCAN_PERIOD = <span class="number">10000</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanLeDevice</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">            <span class="comment">// 在预定义的扫描时间周期后停止扫描.</span></span><br><span class="line">            mHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    mScanning = <span class="keyword">false</span>;</span><br><span class="line">                    mBluetoothAdapter.stopLeScan(mLeScanCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, SCAN_PERIOD);</span><br><span class="line"></span><br><span class="line">            mScanning = <span class="keyword">true</span>;</span><br><span class="line">            mBluetoothAdapter.startLeScan(mLeScanCallback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mScanning = <span class="keyword">false</span>;</span><br><span class="line">            mBluetoothAdapter.stopLeScan(mLeScanCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只想搜索指定类型的外围设备，你可以替换成startLeScan(UUID[], BluetoothAdapter.LeScanCallback)方法，并提供一个你的应用程序所支持的GATT服务的UUID对象数组。</p><p>下面是一个BluetoothAdapter.LeScanCallback的实现，它是一个用于接收BLE搜索结果的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LeDeviceListAdapter mLeDeviceListAdapter;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 设备搜索回调接口.</span></span><br><span class="line"><span class="keyword">private</span> BluetoothAdapter.LeScanCallback mLeScanCallback =</span><br><span class="line">        <span class="keyword">new</span> BluetoothAdapter.LeScanCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLeScan</span><span class="params">(<span class="keyword">final</span> BluetoothDevice device, <span class="keyword">int</span> rssi,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">byte</span>[] scanRecord)</span> </span>&#123;</span><br><span class="line">        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               mLeDeviceListAdapter.addDevice(device);</span><br><span class="line">               mLeDeviceListAdapter.notifyDataSetChanged();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：正如Bluetooth文档中所描述的，在同一个时间你只能搜索BLE设备或者搜索传统蓝牙设备。你不能同时搜索BLE设备和传统蓝牙设备。</p><h1 id="Connecting-to-a-GATT-Server（连接一个GATT服务）"><a href="#Connecting-to-a-GATT-Server（连接一个GATT服务）" class="headerlink" title="Connecting to a GATT Server（连接一个GATT服务）"></a>Connecting to a GATT Server（连接一个GATT服务）</h1><p>与BLE设备交互的第一步就是要连接上它——更准确的说，是连接设备上的GATT服务。连接BLE设备上的GATT服务，你可以使用connectGatt()方法。这个方法需要三个参数：一个Context对象，autoConnect（一个表示是否当BLE设备可访问时马上自动连接的boolean值），还有一个BluetoothGattCallback对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mBluetoothGatt = device.connectGatt(<span class="keyword">this</span>, <span class="keyword">false</span>, mGattCallback);</span><br></pre></td></tr></table></figure><p>上面的代码会连接BLE设备管理的GATT服务，并返回一个BluetoothGatt实例，通过这个实例就可以执行GATT客户端的相关操作。这个调用者（Android应用程序）就是GATT客户端。里面的BluetoothGattCallback对象用于交付操作结果给客户端，例如连接状态，还有将来一些GATT客户端操作的结果。</p><p>在这个例子中，BLE应用程序提供了一个activity（DeviceControlActivity）来连接、显示数据，和显示BLE设备所支持的GATT的service以及characteristic。基于用户的输入，这个activity会和一个名为BluetoothLeService的Service通信，这个service通过Android BLE的API与BLE设备进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个通过Android BLE API与BLE设备进行交互的service.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothLeService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = BluetoothLeService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BluetoothManager mBluetoothManager;</span><br><span class="line">    <span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;</span><br><span class="line">    <span class="keyword">private</span> String mBluetoothDeviceAddress;</span><br><span class="line">    <span class="keyword">private</span> BluetoothGatt mBluetoothGatt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mConnectionState = STATE_DISCONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_DISCONNECTED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_CONNECTING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_CONNECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACTION_GATT_CONNECTED =</span><br><span class="line">            <span class="string">"com.example.bluetooth.le.ACTION_GATT_CONNECTED"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACTION_GATT_DISCONNECTED =</span><br><span class="line">            <span class="string">"com.example.bluetooth.le.ACTION_GATT_DISCONNECTED"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACTION_GATT_SERVICES_DISCOVERED =</span><br><span class="line">            <span class="string">"com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ACTION_DATA_AVAILABLE =</span><br><span class="line">            <span class="string">"com.example.bluetooth.le.ACTION_DATA_AVAILABLE"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXTRA_DATA =</span><br><span class="line">            <span class="string">"com.example.bluetooth.le.EXTRA_DATA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> UUID UUID_HEART_RATE_MEASUREMENT =</span><br><span class="line">            UUID.fromString(SampleGattAttributes.HEART_RATE_MEASUREMENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLE API定义的各个回调方法.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BluetoothGattCallback mGattCallback =</span><br><span class="line">            <span class="keyword">new</span> BluetoothGattCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionStateChange</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> status,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">            String intentAction;</span><br><span class="line">            <span class="keyword">if</span> (newState == BluetoothProfile.STATE_CONNECTED) &#123;</span><br><span class="line">                intentAction = ACTION_GATT_CONNECTED;</span><br><span class="line">                mConnectionState = STATE_CONNECTED;</span><br><span class="line">                broadcastUpdate(intentAction);</span><br><span class="line">                Log.i(TAG, <span class="string">"连接GATT服务."</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">"尝试开始service搜索:"</span> +</span><br><span class="line">                        mBluetoothGatt.discoverServices());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newState == BluetoothProfile.STATE_DISCONNECTED) &#123;</span><br><span class="line">                intentAction = ACTION_GATT_DISCONNECTED;</span><br><span class="line">                mConnectionState = STATE_DISCONNECTED;</span><br><span class="line">                Log.i(TAG, <span class="string">"断开GATT server连接."</span>);</span><br><span class="line">                broadcastUpdate(intentAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// New services discovered</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServicesDiscovered</span><span class="params">(BluetoothGatt gatt, <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">                broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"onServicesDiscovered received: "</span> + status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// Result of a characteristic read operation</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCharacteristicRead</span><span class="params">(BluetoothGatt gatt,</span></span></span><br><span class="line"><span class="function"><span class="params">                BluetoothGattCharacteristic characteristic,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     ...</span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个特定的的回调方法被调用的时候，它就会适当调用broadcastUpdate()帮助方法并传递一个操作标识。注意本节中的数据是根据蓝牙心率测量的profile规范解析的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadcastUpdate</span><span class="params">(<span class="keyword">final</span> String action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line">    sendBroadcast(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">broadcastUpdate</span><span class="params">(<span class="keyword">final</span> String action,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> BluetoothGattCharacteristic characteristic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(action);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照心率测量的profile进行的特定处理.</span></span><br><span class="line">    <span class="comment">// 按照么一个profile规范进行数据解析.</span></span><br><span class="line">    <span class="keyword">if</span> (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = characteristic.getProperties();</span><br><span class="line">        <span class="keyword">int</span> format = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; <span class="number">0x01</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            format = BluetoothGattCharacteristic.FORMAT_UINT16;</span><br><span class="line">            Log.d(TAG, <span class="string">"Heart rate format UINT16."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            format = BluetoothGattCharacteristic.FORMAT_UINT8;</span><br><span class="line">            Log.d(TAG, <span class="string">"Heart rate format UINT8."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heartRate = characteristic.getIntValue(format, <span class="number">1</span>);</span><br><span class="line">        Log.d(TAG, String.format(<span class="string">"Received heart rate: %d"</span>, heartRate));</span><br><span class="line">        intent.putExtra(EXTRA_DATA, String.valueOf(heartRate));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 针对其他profiles, 将数据格式化为16禁止数据.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] data = characteristic.getValue();</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(data.length);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">byte</span> byteChar : data)</span><br><span class="line">                stringBuilder.append(String.format(<span class="string">"%02X "</span>, byteChar));</span><br><span class="line">            intent.putExtra(EXTRA_DATA, <span class="keyword">new</span> String(data) + <span class="string">"\n"</span> +</span><br><span class="line">                    stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendBroadcast(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到DeviceControlActivity，下面的事件通过一个BroadcaseReceiver处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理Service发送过来的各种时间.</span></span><br><span class="line"><span class="comment">// ACTION_GATT_CONNECTED: 连接上了一个GATT服务.</span></span><br><span class="line"><span class="comment">// ACTION_GATT_DISCONNECTED: 断开了一个GATT服务.</span></span><br><span class="line"><span class="comment">// ACTION_GATT_SERVICES_DISCOVERED: 发现了GATT服务.</span></span><br><span class="line"><span class="comment">// ACTION_DATA_AVAILABLE: 从设备接收到数据. 这里可能是一个读取或者通知操作的结果。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mGattUpdateReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) &#123;</span><br><span class="line">            mConnected = <span class="keyword">true</span>;</span><br><span class="line">            updateConnectionState(R.string.connected);</span><br><span class="line">            invalidateOptionsMenu();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) &#123;</span><br><span class="line">            mConnected = <span class="keyword">false</span>;</span><br><span class="line">            updateConnectionState(R.string.disconnected);</span><br><span class="line">            invalidateOptionsMenu();</span><br><span class="line">            clearUI();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BluetoothLeService.</span><br><span class="line">                ACTION_GATT_SERVICES_DISCOVERED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// 显示所有支持的service和characteristic。</span></span><br><span class="line">            displayGattServices(mBluetoothLeService.getSupportedGattServices());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) &#123;</span><br><span class="line">            displayData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Reading-BLE-Attribute（读取BLE属性）"><a href="#Reading-BLE-Attribute（读取BLE属性）" class="headerlink" title="Reading BLE Attribute（读取BLE属性）"></a>Reading BLE Attribute（读取BLE属性）</h1><p>一旦你的Android应用程序连接上了一个GATT服务并且发现了设备上的service，就可以在支持读写的地方读写属性。例如，下面的代码片段通过迭代服务的service和characteristic，并将它们显示在界面上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceControlActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 演示如何迭代所支持的GATT Services/Characteristics.</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们填充绑定到ExpandableListView的数据结构。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayGattServices</span><span class="params">(List&lt;BluetoothGattService&gt; gattServices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gattServices == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        String uuid = <span class="keyword">null</span>;</span><br><span class="line">        String unknownServiceString = getResources().</span><br><span class="line">                getString(R.string.unknown_service);</span><br><span class="line">        String unknownCharaString = getResources().</span><br><span class="line">                getString(R.string.unknown_characteristic);</span><br><span class="line">        ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattServiceData =</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;HashMap&lt;String, String&gt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt; gattCharacteristicData</span><br><span class="line">                = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt;();</span><br><span class="line">        mGattCharacteristics =</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;BluetoothGattCharacteristic&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环迭代可访问的GATT Services.</span></span><br><span class="line">        <span class="keyword">for</span> (BluetoothGattService gattService : gattServices) &#123;</span><br><span class="line">            HashMap&lt;String, String&gt; currentServiceData =</span><br><span class="line">                    <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            uuid = gattService.getUuid().toString();</span><br><span class="line">            currentServiceData.put(</span><br><span class="line">                    LIST_NAME, SampleGattAttributes.</span><br><span class="line">                            lookup(uuid, unknownServiceString));</span><br><span class="line">            currentServiceData.put(LIST_UUID, uuid);</span><br><span class="line">            gattServiceData.add(currentServiceData);</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattCharacteristicGroupData =</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;HashMap&lt;String, String&gt;&gt;();</span><br><span class="line">            List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics =</span><br><span class="line">                    gattService.getCharacteristics();</span><br><span class="line">            ArrayList&lt;BluetoothGattCharacteristic&gt; charas =</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;BluetoothGattCharacteristic&gt;();</span><br><span class="line">           <span class="comment">// 循环迭代可访问的Characteristics.</span></span><br><span class="line">            <span class="keyword">for</span> (BluetoothGattCharacteristic gattCharacteristic :</span><br><span class="line">                    gattCharacteristics) &#123;</span><br><span class="line">                charas.add(gattCharacteristic);</span><br><span class="line">                HashMap&lt;String, String&gt; currentCharaData =</span><br><span class="line">                        <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                uuid = gattCharacteristic.getUuid().toString();</span><br><span class="line">                currentCharaData.put(</span><br><span class="line">                        LIST_NAME, SampleGattAttributes.lookup(uuid,</span><br><span class="line">                                unknownCharaString));</span><br><span class="line">                currentCharaData.put(LIST_UUID, uuid);</span><br><span class="line">                gattCharacteristicGroupData.add(currentCharaData);</span><br><span class="line">            &#125;</span><br><span class="line">            mGattCharacteristics.add(charas);</span><br><span class="line">            gattCharacteristicData.add(gattCharacteristicGroupData);</span><br><span class="line">         &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Receiving-GATT-Notification（接收GATT通知）"><a href="#Receiving-GATT-Notification（接收GATT通知）" class="headerlink" title="Receiving GATT Notification（接收GATT通知）"></a>Receiving GATT Notification（接收GATT通知）</h1><p>BLE应用程序要求在设备的某个指定characteristic改变的时候接收到通知是很常见。下面的代码片段展示了如何通过使用setCharacteristicNotification()为一个characteristic设置通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BluetoothGatt mBluetoothGatt;</span><br><span class="line">BluetoothGattCharacteristic characteristic;</span><br><span class="line"><span class="keyword">boolean</span> enabled;</span><br><span class="line">...</span><br><span class="line">mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);</span><br><span class="line">...</span><br><span class="line">BluetoothGattDescriptor descriptor = characteristic.getDescriptor(</span><br><span class="line">        UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));</span><br><span class="line">descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);</span><br><span class="line">mBluetoothGatt.writeDescriptor(descriptor);</span><br></pre></td></tr></table></figure><p>一旦为一个characteristic启用了通知，当远程设备上的characteristic改变的时候就会触发onCharacteristicChanged()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// Characteristic notification</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCharacteristicChanged</span><span class="params">(BluetoothGatt gatt,</span></span></span><br><span class="line"><span class="function"><span class="params">        BluetoothGattCharacteristic characteristic)</span> </span>&#123;</span><br><span class="line">    broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Closing-the-Client-App（关闭客户端应用程序）"><a href="#Closing-the-Client-App（关闭客户端应用程序）" class="headerlink" title="Closing the Client App（关闭客户端应用程序）"></a>Closing the Client App（关闭客户端应用程序）</h1><p>一旦你的应用程序使用完BLE设备，你应该调用close()方法，这样系统才能适当释放占用的资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBluetoothGatt == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mBluetoothGatt.close();</span><br><span class="line">    mBluetoothGatt = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文地址:<a href="http://developer.android.com/guide/topics/connectivity/bluetooth-le.html" target="_blank" rel="noopener">http://developer.android.com/guide/topics/connectivity/bluetooth-le.html</a></p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/647d650a.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>android:windowSoftInputMode详解</title>
      <link>https://mliyuanbiao.github.io/post/c84ead9.html</link>
      <guid>https://mliyuanbiao.github.io/post/c84ead9.html</guid>
      <pubDate>Thu, 07 Dec 2017 03:25:56 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;Activity 的主窗口与包含屏幕软键盘的窗口的交互方式。 该属性的设置影响两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 Activity 成为用户注意的焦点时软键盘的状态 — 隐藏还是可见。&lt;/li&gt;
&lt;li&gt;对 Activity 主窗口所做的调整 —
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Activity 的主窗口与包含屏幕软键盘的窗口的交互方式。 该属性的设置影响两个方面：</p><ul><li>当 Activity 成为用户注意的焦点时软键盘的状态 — 隐藏还是可见。</li><li>对 Activity 主窗口所做的调整 — 是否将其尺寸调小以为软键盘腾出空间，或者当窗口部分被软键盘遮挡时是否平移其内容以使当前焦点可见。</li></ul><p>该设置必须是下表所列的值之一，或者是一个“state…”值加上一个“adjust…”值的组合。 在任一组中设置多个值（例如，多个“state…”值）都会产生未定义结果。各值之间使用垂直条 (|) 分隔。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; . . . &gt;</span><br></pre></td></tr></table></figure><p>此处设置的值（<code>stateUnspecified</code>和<code>adjustUnspecified</code>除外）替换主题中设置的值。</p><ul><li><p><code>stateUnspecified</code><br>  不指定软键盘的状态（隐藏还是可见）。<br>将由系统选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置。</p></li><li><p><code>stateUnchanged</code><br>  当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。</p></li><li><code>stateHidden</code><br>  当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 隐藏软键盘。</li><li><code>stateAlwaysHidden</code><br>  当 Activity 的主窗口有输入焦点时始终隐藏软键盘。</li><li><code>stateVisible</code><br>  在正常的适宜情况下（当用户向前导航到 Activity 的主窗口时）显示软键盘。</li><li><code>stateAlwaysVisible</code><br>  当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 显示软键盘。</li><li><code>adjustUnspecified</code><pre><code>不指定 Activity 的主窗口是否调整尺寸以为软键盘腾出空间，或者窗口内容是否进行平移以在屏幕上显露当前焦点。 系统会根据窗口的内容是否存在任何可滚动其内容的布局视图来自动选择其中一种模式。 如果存在这样的视图，窗口将进行尺寸调整，前提是可通过滚动在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置。</code></pre></li><li><code>adjustResize</code><br>  始终调整 Activity 主窗口的尺寸来为屏幕上的软键盘腾出空间。</li><li><code>adjustPan</code><br>  不调整 Activity 主窗口的尺寸来为软键盘腾出空间， 而是自动平移窗口的内容，使当前焦点永远不被键盘遮盖，让用户始终都能看到其输入的内容。 这通常不如尺寸调正可取，因为用户可能需要关闭软键盘以到达被遮盖的窗口部分或与这些部分进行交互。</li></ul><p>该属性是在 API 级别 3 引入的。</p><h3 id="引入的版本："><a href="#引入的版本：" class="headerlink" title="引入的版本："></a>引入的版本：</h3><p>API 级别 1，为 <code>noHistory</code> 和 <code>windowSoftInputMode</code> 之外的所有属性引入，这两个属性则是在 API 级别 3 中增加。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/c84ead9.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android Handler机制详解</title>
      <link>https://mliyuanbiao.github.io/post/fecfb901.html</link>
      <guid>https://mliyuanbiao.github.io/post/fecfb901.html</guid>
      <pubDate>Tue, 05 Dec 2017 04:51:08 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Handler</code>是Android的消息机制，他能够很轻松的在线程间传递数据。由于Android开发规范的限制，我们不能在主线程执行耗时操作（如网络，IO操作等），不能在子线程更新UI，所以<code>Handler</code>大部分用来在耗时操作与更新UI之间切换。这让很多人误以为<code>Handler</code>就是用来更新UI的，其实这只是它的一小部分应用。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我相信大多数人对<code>Handler</code>的用法已经烂熟于心了，这篇文章不会去探讨<code>Handler</code>的使用，而是着重从源码上分析<code>Handler</code>的运行机制。</p><p>想要了解<code>Handler</code>的运行机制，我们需要了解 <code>MessageQueue</code> ，<code>Message</code>，<code>Looper</code> 这几个类。</p><ul><li><code>MessageQueue</code> 的意思就是消息队列，它存储了我们需要用来处理的消息<code>Message</code>。</li><li><code>Message</code>是消息类，内部存在一个<code>Bundle</code>对象和几个<code>public</code>字段存储数据，<code>MessageQueue</code>作为一个消息队列不能自己处理消息，所以需要用到<code>Looper</code>。</li><li><code>Looper</code>是一个循环装置，他负责从不断从<code>MessageQueue</code>里取出<code>Message</code>，然后回调给<code>Handler</code>的<code>handleMessage</code>来执行具体操作。</li><li><code>Handler</code>在这里面充当的角色更像是一个辅助类，它让我们不用关系<code>MessageQueue</code>和<code>Looper</code>的具体细节，只需要关系如何发送消息和回调的处理就行了。</li></ul><p>上面讲了几个关键类在<code>Handler</code>运行机制中的职责，相对大家对Handler机制有个粗略的了解。</p><p>我相信各位看官在阅读这篇文章前都是带着问题的，我们将通过问题来解答大家的疑惑。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>在分析<code>Looper</code>之前，我们还需要知道<code>ThreadLocal</code>这个类，如果对<code>ThreadLocal</code>还不太了解，可以去看我的另一篇文章<a href="/2017/10/10/ThreadLocal详解/">《ThreadLocal详解》</a>。</p><h5 id="Looper是如何创建？"><a href="#Looper是如何创建？" class="headerlink" title="Looper是如何创建？"></a>Looper是如何创建？</h5><p><code>Handler</code>执行的线程和它持有的<code>Looper</code>有关。每个<code>Thread</code>都可以创建唯一的Looper对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为当前线程创建Looper对象的方法。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       prepare(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用ThreadLocal来存储当前线程的Looper对象，这保证了每个线程有且仅有一个Looper对象。</span></span><br><span class="line">   <span class="comment">//这里做了非空判断，所以在同一个线程prepare方法是不允许被调用两次的</span></span><br><span class="line">   <span class="comment">//第一次创建好的Looper对象不会被覆盖，它是唯一的。</span></span><br><span class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么主线程的<code>Looper</code>对象是怎么创建的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//其实主线程创建Looper和其他线程没有区别，也是调用prepare()。</span></span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//但是Looper用sMainLooper这个静态变量将主线程的Looper对象存储了起来</span></span><br><span class="line">            <span class="comment">//可以通过getMainLooper()获取，存储MainLooper其实非常有作用，下面会讲到。</span></span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="Looper是如何从MessageQueue取出消息并分发的？"><a href="#Looper是如何从MessageQueue取出消息并分发的？" class="headerlink" title="Looper是如何从MessageQueue取出消息并分发的？"></a>Looper是如何从MessageQueue取出消息并分发的？</h5><p>Looper分发消息的主要逻辑在loop方法里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">       <span class="comment">//保证当前线程必须有Looper对象，如果没有则抛出异常，调用Looper.loop()之前应该先调用Looper.prepare().</span></span><br><span class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//Looper需要不断从MessageQueue中取出消息，所以它持有MessageQueue对象</span></span><br><span class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">       <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">       Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="comment">//这里开始执行死循环，queue通过调用next方法来取出下一个消息。</span></span><br><span class="line">          <span class="comment">//很多人很疑惑死循环不会相当耗费性能吗，如果没有那么多消息怎么办？</span></span><br><span class="line">          <span class="comment">//其实当没有消息的时候，next方法会阻塞在这里，不会往下执行了，性能问题不存在。</span></span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="comment">//这里满足了死循环跳出的条件，即取出的消息为null</span></span><br><span class="line">               <span class="comment">//没有消息next不是会阻塞吗，怎么会返回null呢？</span></span><br><span class="line">               <span class="comment">//其实只有MessageQueue停止的时候（调用quit方法），才会返回null</span></span><br><span class="line">               <span class="comment">//MessageQueue停止后，调用next返回null，且不再接受新消息，下面还有详细介绍。</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">           Printer logging = me.mLogging;</span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                       msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//这里的msg.target是Handler对象，分发消息到Handler去执行。</span></span><br><span class="line">           <span class="comment">//有人问主线程可以创建这么多Handler，怎么保证这个Handler发送的消息不会跑到其它Handler去执行呢？</span></span><br><span class="line">           <span class="comment">//那是因为在发送Message时，他会绑定发送的Handler，在此处分发消息时，也只会回调发送该条消息的Handler。</span></span><br><span class="line">           <span class="comment">//那么分发消息具体在哪个线程执行呢？</span></span><br><span class="line">           <span class="comment">//我觉得这个不该问，那当然是当前方法在哪个线程调用就在哪个线程执行啦。</span></span><br><span class="line">           msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">           <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">           <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">               Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                       + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                       + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                       + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                       + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//这里对Message对象进行回收，会清空所有之前Message设置的数据。</span></span><br><span class="line">       <span class="comment">//正是因为Message有回收机制，我们在创建消息的时候应该优先选择Message.obtain(). </span></span><br><span class="line">       <span class="comment">//如果发送的消息足够多，Message缓存的Message对象不够了，obtain内部会调用new Message()创建一个新的对象。</span></span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="Looper-分发的消息在哪个线程执行？"><a href="#Looper-分发的消息在哪个线程执行？" class="headerlink" title="Looper 分发的消息在哪个线程执行？"></a>Looper 分发的消息在哪个线程执行？</h5><p>先给大家展示一段<code>Looper</code>文档上的示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare(); <span class="comment">//创建LooperThread的Looper对象</span></span><br><span class="line">  </span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//处理发送过来的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        Looper.loop(); <span class="comment">//开始循环消息队列</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码相信很多人都写过，这是一段在子线程创建Handler的案例，其中<code>handleMessage</code>所执行的线程为<code>LooperThread</code>，因为<code>Looper.loop()</code>执行在<code>LooperThread</code>的<code>run</code>方法里。可以在其他线程通过<code>mHandler</code>发送消息到<code>LooperThread</code></p><h5 id="如果不调用Looper-prepare-直接new-Handler-会怎么样呢？"><a href="#如果不调用Looper-prepare-直接new-Handler-会怎么样呢？" class="headerlink" title="如果不调用Looper.prepare()直接new Handler()会怎么样呢？"></a>如果不调用<code>Looper.prepare()</code>直接<code>new Handler()</code>会怎么样呢？</h5><p>我们可以查看<code>Handler</code>的源码看看无参构造是如何运行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用两参构造</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取当前线程的Looper，如果不创建Looper会抛出异常。</span></span><br><span class="line"><span class="comment">//主线程我也没看到有调用Looper.prepare()啊，怎么在主线程不会抛异常呢？这个看下一个问题。</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主线程的Looper对象在哪里创建的？"><a href="#主线程的Looper对象在哪里创建的？" class="headerlink" title="主线程的Looper对象在哪里创建的？"></a>主线程的Looper对象在哪里创建的？</h5><p>从上一个问题可以看出如果不调用<code>Looper.prepare()</code>直接<code>new Handler()</code>就会抛出异常` </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);`</span><br></pre></td></tr></table></figure><p>那么主线程的<code>Looper</code>在哪里创建的呢？首先它是创建了的，因为<code>Looper.getMainLooper() != null</code>，其实<code>MainLooper</code>创建的时间比我们想象的早，它在<code>ActivityThread</code>类里面，<code>ActivityThread</code>是<code>Android</code>的启动类，<code>main</code>方法就在里面（如果有人问你Android有没有main方法，你应该知道怎么回答了吧），而<code>MainLooper</code>就是在<code>main</code>方法里面创建的。</p><p>上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.app.ActivityThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line">    </span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line">    </span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//注意这里，这里创建了主线程的Looper</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">    </span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        AsyncTask.init();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启消息循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MainLooper可以用来做什么"><a href="#MainLooper可以用来做什么" class="headerlink" title="MainLooper可以用来做什么"></a>MainLooper可以用来做什么</h5><h6 id="判断当前线程是否为主线程"><a href="#判断当前线程是否为主线程" class="headerlink" title="判断当前线程是否为主线程"></a>判断当前线程是否为主线程</h6><p>因为Looper是在某一线程唯一的，那么可以在么做。如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前线程的Looper和MainLooper是同一个对象，那么可以认为当前线程是主线程</span></span><br><span class="line">        <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有人说下面这样也可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法其实是不准确的，线程的名称是可以随便更改的。</span></span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName().equals(<span class="string">"main"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以用<code>Looper</code>来判断主线程是很好的做法</p><h6 id="创建运行在主线程的Handler"><a href="#创建运行在主线程的Handler" class="headerlink" title="创建运行在主线程的Handler"></a>创建运行在主线程的Handler</h6><p><code>Handler</code>除了有无参构造，还有一个可以传入<code>Looper</code>的构造。通过指定<code>Looper</code>，可以在任意地方创建运行在主线程的<code>Handler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                <span class="comment">//运行在主线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Looper的quit方法和quitSafely方法有什么区别"><a href="#Looper的quit方法和quitSafely方法有什么区别" class="headerlink" title="Looper的quit方法和quitSafely方法有什么区别"></a>Looper的quit方法和quitSafely方法有什么区别</h5><p>下面是<code>Looper</code>两个方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上是调用的<code>MessageQueue</code>的<code>quit</code>方法<br>下面是<code>MessageQueue</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.os.MessageQueue</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果调用的是quitSafely运行removeAllFutureMessagesLocked，否则removeAllMessagesLocked。</span></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            <span class="comment">//该方法只会清空MessageQueue消息池中所有的延迟消息，</span></span><br><span class="line">            <span class="comment">//并将消息池中所有的非延迟消息派发出去让Handler去处理，</span></span><br><span class="line">            <span class="comment">//quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。</span></span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//该方法的作用是把MessageQueue消息池中所有的消息全部清空，</span></span><br><span class="line">            <span class="comment">//无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息。</span></span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无论是调用了<code>quit</code>方法还是<code>quitSafely</code>方法，<code>MessageQueue</code>将不再接收新的<code>Message</code>，此时消息循环就结束，<code>MessageQueued</code>的<code>next</code>方法将返回<code>null</code>，结束<code>loop()</code>的死循环.这时候再通过<code>Handler</code>调用<code>sendMessage</code>或<code>post</code>等方法发送消息时均返回<code>false</code>，表示消息没有成功放入消息队列<code>MessageQueue</code>中，因为消息队列已经退出了。</p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><h5 id="Message-obtain-和new-Message-如何选择"><a href="#Message-obtain-和new-Message-如何选择" class="headerlink" title="Message.obtain()和new Message()如何选择"></a>Message.obtain()和new Message()如何选择</h5><p><code>Message</code>提供了<code>obtain</code>等多个重载的方法来创建<code>Message</code>对象，那么这种方式和直接<code>new</code>该如何选择。下面看看<code>obtain</code>的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">//只有当从对象池里取不出Message才去new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//清除所有使用过的痕迹</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>;</span><br><span class="line">        sendingUid = -<span class="number">1</span>;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收到对象池</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，通过<code>obtain</code>方法是从对象池取，而<code>new</code>是创建了一个新的对象。我们应该使用<code>obtain</code>来创建<code>Message</code>对象，每次使用完后都会自动进行回收，节省内存。</p><p>未完待续……</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/fecfb901.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android应用内安装App的几种姿势</title>
      <link>https://mliyuanbiao.github.io/post/7bdf5ef8.html</link>
      <guid>https://mliyuanbiao.github.io/post/7bdf5ef8.html</guid>
      <pubDate>Fri, 27 Oct 2017 09:16:58 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h4 id=&quot;调用系统安装程序&quot;&gt;&lt;a href=&quot;#调用系统安装程序&quot; class=&quot;headerlink&quot; title=&quot;调用系统安装程序&quot;&gt;&lt;/a&gt;调用系统安装程序&lt;/h4&gt;&lt;p&gt;这种方式最为简单，只需要调起系统界面即可。看代码&lt;/p&gt;
&lt;figure
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="调用系统安装程序"><a href="#调用系统安装程序" class="headerlink" title="调用系统安装程序"></a>调用系统安装程序</h4><p>这种方式最为简单，只需要调起系统界面即可。看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用系统安装界面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apkFile</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startInstallActivity</span><span class="params">(Context context, File apkFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (apkFile == <span class="keyword">null</span> || !apkFile.exists()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    intent.setDataAndType(Uri.parse(<span class="string">"file://"</span> + apkFile.toString()), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="调用系统pm命令"><a href="#调用系统pm命令" class="headerlink" title="调用系统pm命令"></a>调用系统pm命令</h4><p>这种方式是在通过终端执行<em>pm</em>命令来实现 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm install -r [filepath]</span><br></pre></td></tr></table></figure><p>其中<code>-r</code>代表覆盖安装。<br>这种方式可以实现静默安装，不需要调起系统界面。但是有一个前提，就是需要<em>root</em>权限，没有去<em>root</em>权限，<em>pm</em>命令不能执行。获取<em>root</em>权限不是本文范畴，请自行百度或者google。</p><p>满足前提的情况下，我们可能用到以下方法。</p><ul><li>判断设备是否有root权限,通过执行su命令是否正确来检查设备是否被root</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查设备是否被root</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Process process = Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">        process.getOutputStream().write(<span class="string">"exit\n"</span>.getBytes());</span><br><span class="line">        process.getOutputStream().flush();</span><br><span class="line">        <span class="keyword">int</span> i = process.waitFor();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行终端命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行终端命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">execRootCmdSilent</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process p = Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">            dos = <span class="keyword">new</span> DataOutputStream(p.getOutputStream());</span><br><span class="line">            Log.i(TAG, cmd);</span><br><span class="line">            dos.writeBytes(cmd + <span class="string">"\n"</span>);</span><br><span class="line">            dos.flush();</span><br><span class="line">            dos.writeBytes(<span class="string">"exit\n"</span>);</span><br><span class="line">            dos.flush();</span><br><span class="line">            p.waitFor();</span><br><span class="line">            result = p.exitValue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>安装apk，在终端执行 <code>pm install -r filePath</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installApk</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (TextUtils.isEmpty(filePath) || !<span class="keyword">new</span> File(filePath).exists()) <span class="keyword">return</span>;</span><br><span class="line">   execRootCmdSilent(<span class="string">"pm install -r "</span> + filePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="反射PackageManager的installPackage方法"><a href="#反射PackageManager的installPackage方法" class="headerlink" title="反射PackageManager的installPackage方法"></a>反射<em>PackageManager</em>的<em>installPackage</em>方法</h4><p>通过查看查看系统安装程序的源码，可以看到系统安装程序实际上是调用<em>PackageManager</em>的<em>installPackage</em>方法来实现安装的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> replaced by &#123;<span class="doctag">@link</span> PackageInstaller&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">installPackage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Uri packageURI, //APK地址</span></span></span><br><span class="line"><span class="function"><span class="params">            IPackageInstallObserver observer, //安装回调</span></span></span><br><span class="line"><span class="function"><span class="params">            @InstallFlags <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            String installerPackageName)</span></span>; <span class="comment">//被安装APK的包名</span></span><br></pre></td></tr></table></figure><ul><li><p><em>installPackage</em>方法虽然是<em>public</em>修饰的，但是同时被<em>@hide</em>了，所以应用程序无法直接调用，这就需要用到反射机制了。</p></li><li><p>调用这个方法需要系统权限，所以需要用系统签名对apk打包，具体操作可以参考<a href="http://connorlin.github.io/2016/04/27/让Android-Studio支持系统签名&#40;证书&#41;" target="_blank" rel="noopener">这篇文章</a></p></li><li><p><em>IPackageInstallObserver</em>是一个<em>AIDL</em>接口，所以我们需要用到<em>IPackageInstallObserver.aidl</em> 这个文件。你可以</p><ul><li><p>直接从系统源码拷贝，该文件位于<code>/frameworks/base/core/java/android/content/pm</code></p></li><li><p>或者拷贝我的，在你的项目下创建<code>app/src/main/aidl/android/content/pm/IPackageInstallObserver.aidl</code>文件，然后将下面的代码复制进去</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> android.content.pm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * API for installation callbacks from the Package Manager.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IPackageInstallObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">packageInstalled</span><span class="params">(in String packageName, <span class="keyword">int</span> returnCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上述都做好了之后。</p><ul><li>调用安装的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//installPackage方法名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTALL_METHOD = <span class="string">"installPackage"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InstallFlags</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORWARD_LOCK = <span class="number">0x00000001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_REPLACE_EXISTING = <span class="number">0x00000002</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_ALLOW_TEST = <span class="number">0x0000000</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_EXTERNAL = <span class="number">0x00000008</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_INTERNAL = <span class="number">0x00000010</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FROM_ADB = <span class="number">0x00000020</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_ALL_USERS = <span class="number">0x00000040</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_ALLOW_DOWNGRADE = <span class="number">0x00000080</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_GRANT_RUNTIME_PERMISSIONS = <span class="number">0x00000100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORCE_VOLUME_UUID = <span class="number">0x00000200</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORCE_PERMISSION_PROMPT = <span class="number">0x00000400</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_EPHEMERAL = <span class="number">0x00000800</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_DONT_KILL_APP = <span class="number">0x00001000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORCE_SDK = <span class="number">0x00002000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONT_KILL_APP = <span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installPackage</span><span class="params">(Context context, File file, IPackageInstallObserver observer)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    Method method = PackageManager.class.getDeclaredMethod(INSTALL_METHOD, Uri.class,</span><br><span class="line">            IPackageInstallObserver.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">    method.invoke(packageManager, Uri.fromFile(file), observer, INSTALL_REPLACE_EXISTING | INSTALL_DONT_KILL_APP, GetAppInfo.getAPKPackageName(context, file.getAbsolutePath()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>监听安装回调</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//安装回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageInstallObserver</span> <span class="keyword">extends</span> <span class="title">IPackageInstallObserver</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">packageInstalled</span><span class="params">(String packageName, <span class="keyword">int</span> returnCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(returnCode == INSTALL_SUCCEEDED)&#123;</span><br><span class="line">            <span class="comment">//安装成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//returnCode的取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_SUCCEEDED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_ALREADY_EXISTS = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INVALID_APK = -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INVALID_URI = -<span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INSUFFICIENT_STORAGE = -<span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_DUPLICATE_PACKAGE = -<span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_NO_SHARED_USER = -<span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_UPDATE_INCOMPATIBLE = -<span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_SHARED_USER_INCOMPATIBLE = -<span class="number">8</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_MISSING_SHARED_LIBRARY = -<span class="number">9</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_REPLACE_COULDNT_DELETE = -<span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_DEXOPT = -<span class="number">11</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_OLDER_SDK = -<span class="number">12</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_CONFLICTING_PROVIDER = -<span class="number">13</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_NEWER_SDK = -<span class="number">14</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_TEST_ONLY = -<span class="number">15</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -<span class="number">16</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_MISSING_FEATURE = -<span class="number">17</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_CONTAINER_ERROR = -<span class="number">18</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INVALID_INSTALL_LOCATION = -<span class="number">19</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_MEDIA_UNAVAILABLE = -<span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_VERIFICATION_TIMEOUT = -<span class="number">21</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_VERIFICATION_FAILURE = -<span class="number">22</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_PACKAGE_CHANGED = -<span class="number">23</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_UID_CHANGED = -<span class="number">24</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_VERSION_DOWNGRADE = -<span class="number">25</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE = -<span class="number">26</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_NOT_APK = -<span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_BAD_MANIFEST = -<span class="number">101</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION = -<span class="number">102</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_NO_CERTIFICATES = -<span class="number">103</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES = -<span class="number">104</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING = -<span class="number">105</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME = -<span class="number">106</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID = -<span class="number">107</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_MANIFEST_MALFORMED = -<span class="number">108</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_MANIFEST_EMPTY = -<span class="number">109</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INTERNAL_ERROR = -<span class="number">110</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_USER_RESTRICTED = -<span class="number">111</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_DUPLICATE_PERMISSION = -<span class="number">112</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_NO_MATCHING_ABIS = -<span class="number">113</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_NATIVE_LIBRARIES = -<span class="number">114</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_ABORTED = -<span class="number">115</span>;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/7bdf5ef8.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何理解Kotlin中属性</title>
      <link>https://mliyuanbiao.github.io/post/6585af7e.html</link>
      <guid>https://mliyuanbiao.github.io/post/6585af7e.html</guid>
      <pubDate>Fri, 27 Oct 2017 07:59:12 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;属性的定义&quot;&gt;&lt;a href=&quot;#属性的定义&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h2><p>在<strong>kotlin</strong>中，<strong>var</strong>和<strong>val</strong>是用来声明属性的两个关键字，在<strong>kotlin</strong>官方参考文档上是这么说的。</p><blockquote><p><strong>Kotlin</strong>的类可以有属性。 属性可以用关键字 <strong>var</strong>声明为可变的，否则使用只读关键字<strong>val</strong>。</p></blockquote><p>那什么是可变属性，什么又是可读属性呢？我们在问这个问题前可以先回顾一下java对属性的定义。</p><blockquote><p>属性可以通过<strong>get</strong>、<strong>set</strong>、<strong>is</strong>（可以替代<strong>get</strong>，用在布尔型属性上）方法或遵循特定命名规范的其他方法访问。</p></blockquote><p>在这里我们可以理解为，在<strong>java</strong>中，对一个字段生成<strong>public</strong>的<strong>set get</strong>方法，那么他就是一个可变（可读可写）属性，仅提供<strong>public get</strong>或者<strong>set</strong>被<strong>private</strong>修饰的就是一个只读属性。</p><p>在kotlin中我们是如何定义属性的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个String类型的属性name</span></span><br><span class="line">    var name: String? = <span class="keyword">null</span></span><br><span class="line">    <span class="comment">//定义一个Boolean类型的属性deceased</span></span><br><span class="line">    var deceased: Boolean? = <span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin和java同属于jvm语言，编译后会生成class文件。我将上面的kotlin代码生成的class再次反编译成java代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> Boolean deceased = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(@Nullable String var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Boolean <span class="title">getDeceased</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.deceased;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDeceased</span><span class="params">(@Nullable Boolean var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.deceased = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里你会发现，反编译后代码和java属性的定义是一毛一样有木有。所以<strong>kotlin</strong>的属性，在<strong>java</strong>代码中可以通过<strong>set get</strong>方法来调用。</p><h2 id="只读属性和常量"><a href="#只读属性和常量" class="headerlink" title="只读属性和常量"></a>只读属性和常量</h2><p>有的地方说，<strong>var</strong>是声明变量的，<strong>val</strong>是声明常量的。这个其实不是完全正确，至少<strong>val</strong>在官方参考文档上说的是只读属性，而不是常量。比方说温度，我们可以获取温度的变化，但是不能人为直接改变温度，那么温度就是只读属性，而不是常量。<br>再比如说list的isEmpty属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>isEmpty属性受到size的改变而改变，但是无法主动去设置isEmpty的值。那么isEmpty就是个只读属性。</p><p>在这里要分为几种情况来理解<strong>val</strong>。</p><ul><li><strong>val</strong>声明的属性被字面量或者表达式赋值的时候</li><li><strong>val</strong>声明的属性实现了自定义的<strong>get</strong>方法</li></ul><p>看下面的例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的name属性被字面量“zhangsan”赋值了</span></span><br><span class="line">    <span class="keyword">val</span> name: String? = <span class="string">"zhangsan"</span></span><br><span class="line">     <span class="comment">//age属性的值受birthday的影响</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> Calendar.getInstance().<span class="keyword">get</span>(Calendar.YEAR) - birthday</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> birthday: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 反编译成<strong>java</strong>代码是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//name属性被字面量赋值，编译后会加上final关键字，成为真正的常量</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> birthday;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//age属性只实现了get方法，无法通过set方法来改变值，是个只读属性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Calendar.getInstance().get(<span class="number">1</span>) - <span class="keyword">this</span>.birthday;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.birthday;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.birthday = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是变量的幕后字段"><a href="#什么是变量的幕后字段" class="headerlink" title="什么是变量的幕后字段"></a>什么是变量的幕后字段</h2><p>在<strong>kotlin</strong>中可以通过关键字声明属性，那可不可以声明字段呢？它有没有字段呢？<br>答：<strong>kotlin</strong>中不能声明字段，但是<strong>kotlin</strong>中是有字段的，他有一个幕后字段的概念，每一个属性可以有一个幕后字段，也可以没有。</p><p>拿上面的例子再讲一遍</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEmpty <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>isEmpty的值只和size有关，那么在反编译之后，不会出现如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>这里可以得出一个结论，属性不一定非得有字段。对<strong>java</strong>属性定义的后半句是这么说的，“<em>或遵循特定命名规范的其他方法访问</em>”，所以关键看方法的定义，比如说在一个类里面有<strong>setWidth()</strong>,<strong>getWidth()</strong>这两个方法。就可以认定为这个类有<strong>width</strong>属性，但是不一定有<strong>width</strong>这个字段。</p><p>也就是说这个属性没有幕后字段。</p><p>再看下面这个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name属性没有实现自定义的set get方法</span></span><br><span class="line"><span class="keyword">var</span> name:String? = <span class="literal">null</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">name = <span class="string">"zhangsan"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> len = name.length()</span><br></pre></td></tr></table></figure><p><strong>name</strong>没有实现自定义的<strong>set get</strong>方法，字面值”zhangsan”需要一个字段来赋值。那么在class里面会生成 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个就是name属性的幕后字段</span></span><br><span class="line"><span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>那么幕后字段可以用代码访问到么，这个是可以的，使用 <strong>field</strong> 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这句代码其实和下面的代码是等价的，没有区别。</span></span><br><span class="line"><span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">set</span>(value) &#123;</span><br><span class="line">       field = value</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">get</span>() &#123;</span><br><span class="line">       <span class="keyword">return</span> field</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>讲到这里我相信大家对幕后字段已经有了一定的了解。</p><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>在kotlin声明一个扩展属性的方法如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Person.city:String <span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="string">"city"</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：扩展属性只能用生成自定义set get方法来实现，不能直接用字面量来赋值。所以下面的代码是错的</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Person.city:String = <span class="string">"city"</span></span><br></pre></td></tr></table></figure><p>第二句代码是无法编译通过的，那是因为</p><blockquote><p>扩展是静态解析的.扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成 员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数,或者属性。由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就 是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 <strong>get/set</strong> 定义。</p></blockquote><p>静态解析的结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getCity</span><span class="params">(@NotNull Person $receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"city"</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以扩展仅仅是可以通过点语法来调用，并不是真正插入类里面，也不存在幕后字段。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>属性可以通过<strong>get</strong>、<strong>set</strong>、<strong>is</strong>（可以替代<strong>get</strong>，用在布尔型属性上）方法或遵循特定命名规范的其他方法访问。</li><li>只读属性和常量不是同一个概念，具体看上头。</li><li>属性可以有一个幕后字段，也可以没有</li><li>扩展是静态解析的，扩展属性是没有幕后字段的</li><li>扩展只是能通过点语法调用而已。</li></ul>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/6585af7e.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java转Kotlin boolean属性的坑</title>
      <link>https://mliyuanbiao.github.io/post/2d13bd4b.html</link>
      <guid>https://mliyuanbiao.github.io/post/2d13bd4b.html</guid>
      <pubDate>Fri, 27 Oct 2017 03:59:22 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;踩坑&quot;&gt;&lt;a href=&quot;#踩坑&quot; class=&quot;headerlink&quot; title=&quot;踩坑&quot;&gt;&lt;/a&gt;踩坑&lt;/h3&gt;&lt;p&gt;假设一个 &lt;code&gt;JavaBean&lt;/code&gt; 类中有 &lt;code&gt;boolean&lt;/code&gt; 类型的字段叫做
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>假设一个 <code>JavaBean</code> 类中有 <code>boolean</code> 类型的字段叫做 <code>enabled</code><br>它生成的<code>setter</code>/<code>getter</code> 方法将是</p><ul><li>setter: <code>setEnabled(boolean enabled)</code></li><li>getter: <code>isEnabled()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enabled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 <code>Android Studio</code> 的 <code>kotlin</code> 插件转换后将生成 <code>isEnabled</code> 属性，而不是 <code>enabled</code> 属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isEnabled: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>kotlin</code>编译后也是生成<code>class</code>文件，所以也是可以转成<code>java</code>文件的，通过查看反编译后的结果来学习<code>kotlin</code>不失为一种好方法。</p><p>可以在 <code>Android Studio</code> 执行下面的操作将 <code>kotlin</code> 代码重新转成<code>java</code>代码。<br>Tools / Kotlin / Show Kotlin Bytecode / Decompile. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> isEnabled;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.isEnabled;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.isEnabled = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是 <code>isEnabled</code> ，不是 <code>enabled</code>。</p><h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><ul><li><p>我在项目中使用的是<strong>Gson</strong>来解析后台返回来的数据。<strong>Gson</strong>是通过反射字段的名称来赋值的，然而数据中是 <code>enbaled</code> ，代码里是 <code>isEnabled</code> ，它将永远不能被赋值，永远为<code>false</code>，解决方法可以是</p><ul><li>给字段添加 <code>@SerializedName(value = &quot;enbaled&quot;)</code></li><li>直接将 <code>isEnabled</code> 改成 <code>enbaled</code>，保证kotlin的幕后字段与后台返回数据一致即可.</li></ul></li><li><p>如果你项目中用的是<strong>fastjson</strong>，那么需要为每个字段添加<code>setter</code>/<code>getter</code> 方法。<strong>fastjson</strong>是根据<strong>Javabean</strong>属性来赋值的，所以必须保证属性名正确。由于之前<strong>fastjson</strong>出现过序列化成功，但是反序列化失败的bug，致使我放弃使用<strong>fastjson</strong>。虽然<strong>fastjson</strong>以快著称，但是快不是唯一的需求，它只在数据量大的时候有明显差异，数据量小的时候差异几乎可是忽略不计，所以我选择<strong>Gson</strong>。</p></li></ul><h3 id="细谈Java属性"><a href="#细谈Java属性" class="headerlink" title="细谈Java属性"></a>细谈Java属性</h3><p>在Java里面生成 <code>setter</code>/<code>getter</code> 方法是有一定规则的。</p><ul><li>如果类的成员变量的名字是xxx，那么为了更改或获取成员变量的值，即更改或获取属性，在类中可以使用两个方法：<ul><li>getXxx()，用来获取属性xxx。</li><li>setXxx()，用来修改属性xxx.。</li></ul></li><li>对于boolean类型的成员变量，即布尔逻辑类型的属性，允许使用”is”代替上面的”get”。</li><li>类中访问属性的方法都必须是public的，一般属性是private的。</li><li>类中如果有构造方法，那么这个构造方法也是public的并且是无参数的。</li></ul><p>因为Java属性是由 <code>setter</code>/<code>getter</code> 方法决定的，而不是字段。在一个Java类里面，如果有<code>void setName(String name)</code>和<code>String getName()</code>方法，那么可以认为这个类有<code>name</code>这个属性（<strong>可读可写</strong>），如果仅有get，那么这个<code>name</code>属性就是个<strong>只读属性</strong>。即使没有<code>name</code>这个字段也是一样成立的。</p><p>也就是说，对于 <code>boolean</code> 类型，<code>enabled</code> 和 <code>isEnabled</code> 这两个字段生成的<code>setter</code>/<code>getter</code> 方法是一致的。当这两个字段同时存在时，只能针对其中一个生成<code>setter</code>/<code>getter</code> 方法。看下图你就明白了</p><p><img src="/media/15057241768106.jpg" alt=""></p><p><code>isEnabled</code> 已经无法再生成了，因为已经存在了。在项目当中应该避免则这样的命名，选择其一即可。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/2d13bd4b.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>自定义PAC列表规则</title>
      <link>https://mliyuanbiao.github.io/post/d8b20b90.html</link>
      <guid>https://mliyuanbiao.github.io/post/d8b20b90.html</guid>
      <pubDate>Wed, 25 Oct 2017 02:35:05 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h4 id=&quot;规则大概描述如下&quot;&gt;&lt;a href=&quot;#规则大概描述如下&quot; class=&quot;headerlink&quot; title=&quot;规则大概描述如下&quot;&gt;&lt;/a&gt;规则大概描述如下&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通配符支持，如 &lt;em&gt;.example.com/&lt;/em&gt; 实际书写时可省略
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="规则大概描述如下"><a href="#规则大概描述如下" class="headerlink" title="规则大概描述如下"></a>规则大概描述如下</h4><ul><li>通配符支持，如 <em>.example.com/</em> 实际书写时可省略 <em> 如 .example.com/ 意即 </em>.example.com/*</li><li>正则表达式支持，以\开始和结束， 如 [\w]+://example.com\</li><li>例外规则 @@，如 @@.example.com/ 满足@@后规则的地址不使用代理<br>匹配地址开始和结尾 |，如 |<a href="http://example.com、example.com|" target="_blank" rel="noopener">http://example.com、example.com|</a> 分别表示以 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 开始和以 example.com 结束的地址</li><li>|| 标记，如 ||example.com 则 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 、<a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> 、<a href="ftp://example.com" target="_blank" rel="noopener">ftp://example.com</a> 等地址均满足条件，只用于匹配地址开头</li><li>注释 ! 如 ! Comment</li><li>分隔符^，表示除了字母、数字或者 _ - . % 之外的任何字符。如 <a href="http://example.com^" target="_blank" rel="noopener">http://example.com^</a> ，<a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> 和 <a href="http://example.com:8000/" target="_blank" rel="noopener">http://example.com:8000/</a> 均满足条件，而 <a href="http://example.com.ar/" target="_blank" rel="noopener">http://example.com.ar/</a> 不满足条件</li></ul><h4 id="如何使用自定义规则"><a href="#如何使用自定义规则" class="headerlink" title="如何使用自定义规则"></a>如何使用自定义规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https://adblockplus.org/en/filter-cheatsheet</span><br><span class="line">||amazonaws.com</span><br><span class="line">||atom.io</span><br><span class="line">||github.com^</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/d8b20b90.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 继承与原型链</title>
      <link>https://mliyuanbiao.github.io/post/d14050d0.html</link>
      <guid>https://mliyuanbiao.github.io/post/d14050d0.html</guid>
      <pubDate>Tue, 10 Oct 2017 06:38:04 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;blockquote&gt;
&lt;p&gt;原文:&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>原文:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p></blockquote><p>对于有基于类的语言经验的开发人员来说，JavaScript 有点令人困惑 (如Java或C ++) ，因为它是动态的，并且本身不提供一个<code>class</code>实现。（在ES2015/ES6中引入了<code>class</code>关键字，但只是语法糖，JavaScript 仍然是基于原型的）。</p><p>当谈到继承时，JavaScript 只有一种结构：对象。每个对象都有一个私有属性（称之为 [[Prototype]]），它持有一个连接到另一个称为其 <strong>prototype</strong> 对象（原型对象）的链接。该 prototype 对象又具有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>。（译者注：<code>Object.getPrototypeOf(Object.prototype) === null; // true</code>）根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p><p>JavaScript 中几乎所有的对象都是位于原型链顶端的<code>Object</code>的实例。</p><p>原型继承经常被视为 JavaScript 的一个弱点，但事实上，原型继承模型比经典的继承模型更加强大。例如，在一个原型模型之上构建一个经典模型是相当容易的。</p><h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><blockquote><p>遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指向 someObject的原型。从 ECMAScript 6 开始，[[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <strong>proto</strong>。</p></blockquote><blockquote><p>它不应该与函数(function)的func.prototype属性相混淆，func.prototype的作用是使用 new func() 创建的对象的实例的 [[Prototype]]。Object.prototype属性表示Object的原型对象。</p></blockquote><p>这里演示当尝试访问属性时会发生什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：</span></span><br><span class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="comment">// o 的原型 o.__proto__有属性 b 和 c：</span></span><br><span class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></span><br><span class="line"><span class="comment">// 最后, o.__proto__.__proto__ 是 null.</span></span><br><span class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></span><br><span class="line"><span class="comment">// 根据定义，null 没有__proto__.</span></span><br><span class="line"><span class="comment">// 综上，整个原型链如下: </span></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为2</span></span><br><span class="line"><span class="comment">// o.__proto__上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// c是o的自身属性吗？不是，那看看o.__proto__上有没有.</span></span><br><span class="line"><span class="comment">// c是o.__proto__的自身属性吗？是的,该属性的值为4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// d是o的自身属性吗？不是,那看看o.__proto__上有没有.</span></span><br><span class="line"><span class="comment">// d是o.__proto__的自身属性吗？不是，那看看o.__proto__.__proto__上有没有.</span></span><br><span class="line"><span class="comment">// o.__proto__.__proto__为null，停止搜索，</span></span><br><span class="line"><span class="comment">// 没有d属性，返回undefined</span></span><br></pre></td></tr></table></figure><p>将属性设置为对象将创建自己的属性。获取和设置属性的唯一限制是内置 getter 或 setter 的属性。</p><h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 <strong>JavaScript</strong> 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性覆盖”（这种情况相当于其他语言的方法重写）。</p><p>当继承的函数被调用时，<code>this</code> 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.m()); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 当调用 o.m 时,'this'指向了o.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line"><span class="comment">// p是一个对象, p.__proto__是o.</span></span><br><span class="line"></span><br><span class="line">p.a = <span class="number">4</span>; <span class="comment">// 创建 p 的自身属性a.</span></span><br><span class="line"><span class="built_in">console</span>.log(p.m()); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 调用 p.m 时, 'this'指向 p. </span></span><br><span class="line"><span class="comment">// 又因为 p 继承 o 的 m 函数</span></span><br><span class="line"><span class="comment">// 此时的'this.a' 即 p.a，即 p 的自身属性 'a'</span></span><br></pre></td></tr></table></figure><h2 id="使用不同的方法来创建对象和生成原型链"><a href="#使用不同的方法来创建对象和生成原型链" class="headerlink" title="使用不同的方法来创建对象和生成原型链"></a>使用不同的方法来创建对象和生成原型链</h2><h3 id="使用普通语法创建对象"><a href="#使用普通语法创建对象" class="headerlink" title="使用普通语法创建对象"></a>使用普通语法创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// o这个对象继承了Object.prototype上面的所有属性</span></span><br><span class="line"><span class="comment">// 所以可以这样使用 o.hasOwnProperty('a').</span></span><br><span class="line"><span class="comment">// hasOwnProperty 是Object.prototype的自身属性。</span></span><br><span class="line"><span class="comment">// Object.prototype的原型为null。</span></span><br><span class="line"><span class="comment">// 原型链如下:</span></span><br><span class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组都继承于Array.prototype </span></span><br><span class="line"><span class="comment">// (indexOf, forEach等方法都是从它继承而来).</span></span><br><span class="line"><span class="comment">// 原型链如下:</span></span><br><span class="line"><span class="comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数都继承于Function.prototype</span></span><br><span class="line"><span class="comment">// (call, bind等方法都是从它继承而来):</span></span><br><span class="line"><span class="comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure><h3 id="使用构造器"><a href="#使用构造器" class="headerlink" title="使用构造器"></a>使用构造器</h3><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">new 操作符</a> 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.vertices = [];</span><br><span class="line">  <span class="keyword">this</span>.edges = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph.prototype = &#123;</span><br><span class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="comment">// g是生成的对象,他的自身属性有'vertices'和'edges'.</span></span><br><span class="line"><span class="comment">// 在g被实例化时,g.__proto__指向了Graph.prototype.</span></span><br></pre></td></tr></table></figure><h3 id="使用-Object-create"><a href="#使用-Object-create" class="headerlink" title="使用 Object.create"></a>使用 <code>Object.create</code></h3><p>ECMAScript 5 中引入了一个新方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener"><code>Object.create()</code></a>。可以调用这个方法来创建一个新对象。新对象的原型就是调用 <code>create</code> 方法时传入的第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</span><br><span class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// d ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></span><br></pre></td></tr></table></figure><h3 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 <code>class</code> 关键字</h3><p>ECMAScript6 引入了一套新的关键字用来实现 <code>class</code>。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 <code>class</code>, <code>constructor</code>，<code>static</code>，<code>extends</code> 和 <code>super</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</span><br><span class="line">    <span class="keyword">super</span>(sideLength, sideLength);</span><br><span class="line">  &#125;</span><br><span class="line">  get area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  set sideLength(newLength) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = newLength;</span><br><span class="line">    <span class="keyword">this</span>.width = newLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p><p>遍历对象的属性时，原型链上的<strong>每个</strong>可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从<code>Object.prototype</code>继承的 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener"><font color="red">hasOwnProperty</font></a> 方法。下面给出一个具体的例子来说明它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(g.hasOwnProperty(<span class="string">'vertices'</span>));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.hasOwnProperty(<span class="string">'nope'</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.hasOwnProperty(<span class="string">'addVertex'</span>));</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g.__proto__.hasOwnProperty(<span class="string">'addVertex'</span>));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener"><font color="red">hasOwnProperty</font></a>是JavaScript中唯一处理属性的东西，并且不支持原型链。</p><p>注意：检查属性是否<code>undefined</code>还不够。该属性可能存在，但其值恰好设置为<code>undefined</code>。</p><h3 id="错误实践：扩展原生对象的原型"><a href="#错误实践：扩展原生对象的原型" class="headerlink" title="错误实践：扩展原生对象的原型"></a>错误实践：扩展原生对象的原型</h3><p>经常使用的一个错误实践是扩展<code>Object.prototype</code>或其他内置原型。</p><p>这种技术被称为猴子补丁并且会破坏封装。尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。</p><p>扩展内置原型的唯一理由是支持JavaScript 引擎的新特性，如<code>Array.forEach</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>B</code> 继承自 <code>A</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.varA = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上函数 A 的定义中，既然 A.prototype.varA 总是会被 this.varA 遮蔽，</span></span><br><span class="line"><span class="comment">// 那么将 varA 加入到原型（prototype）中的目的是什么？</span></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  varA : <span class="literal">null</span>,  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">既然它没有任何作用，干嘛不将 varA 从原型（prototype）去掉 ? </span></span><br><span class="line"><span class="comment">也许作为一种在隐藏类中优化分配空间的考虑 ?</span></span><br><span class="line"><span class="comment">https://developers.google.com/speed/articles/optimizing-javascript </span></span><br><span class="line"><span class="comment">如果varA并不是在每个实例中都被初始化，那这样做将是有效果的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  doSomething : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  A.call(<span class="keyword">this</span>, a);</span><br><span class="line">  <span class="keyword">this</span>.varB = b;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype, &#123;</span><br><span class="line">  varB : &#123;</span><br><span class="line">    value: <span class="literal">null</span>, </span><br><span class="line">    enumerable: <span class="literal">true</span>, </span><br><span class="line">    configurable: <span class="literal">true</span>, </span><br><span class="line">    writable: <span class="literal">true</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething : &#123; </span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// override</span></span><br><span class="line">      A.prototype.doSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </span><br><span class="line">      <span class="comment">// call super</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>, </span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">B.prototype.constructor = B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.doSomething();</span><br></pre></td></tr></table></figure><p>最重要的部分是：</p><ul><li>类型被定义在 <code>.prototype</code> 中</li><li>用 <code>Object.create()</code> 来继承</li></ul><h2 id="prototype和Object-getPrototypeOf"><a href="#prototype和Object-getPrototypeOf" class="headerlink" title="prototype和Object.getPrototypeOf"></a><code>prototype</code>和<code>Object.getPrototypeOf</code></h2><p>对于从 Java 或 C++ 转过来的开发人员来说 JavaScript 会有点让人困惑，因为它全部都是动态的，都是运行时，而且不存在类（classes）。所有的都是实例（对象）。即使我们模拟出的 “类（classes）”，也只是一个函数对象。</p><p>你可能已经注意到我们的<code>function A</code>有一个叫做<code>prototype</code>的特殊属性。该特殊属性可与 JavaScript 的 new 操作符一起使用。对原型对象的引用被复制到新实例的内部<code>[[Prototype]]</code>属性。例如，当执行<code>var a1 = new A()</code>时，JavaScript（在内存中创建对象之前，并且在运行函数A()之前）定义了它）设置a1.<code>[[Prototype]] = A.prototype</code>。然后当您访问实例的属性时，JavaScript首先会检查它们是否直接存在于该对象上，如果不存在，则会<code>[[Prototype]]</code>中查找。这意味着你在<code>prototype</code>中定义的所有内容都可以由所有实例有效共享，你甚至可以稍后更改部分<code>prototype</code>，并在所有现有实例中显示更改（如果需要）。</p><p>像上面的例子中，如果你执行<code>var a1 = new A(); var a2 = new A();</code> 那么 <code>a1.doSomething</code>事实上会指向<code>Object.getPrototypeOf(a1).doSomething</code>，它就是你在 <code>A.prototype.doSomething</code> 中定义的内容。比如：<code>Object.getPrototypeOf(a1).doSomething == Object.getPrototypeOf(a2).doSomething == A.prototype.doSomething</code>。</p><p>简而言之， <code>prototype</code>是用于类型的，而 <code>Object.getPrototypeOf()</code> 是用于实例的（instances），两者功能一致。</p><p><code>[[Prototype]]</code> 看起来就像递归引用， 如<code>a1.doSomething，Object.getPrototypeOf(a1).doSomething，Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething</code> 等等等， 直到它被找到或<code>Object.getPrototypeOf</code>返回 <code>null</code>。</p><p>因此，当你执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure><p>JavaScript 实际上执行的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.__proto__ = Foo.prototype;</span><br><span class="line">Foo.call(o);</span><br></pre></td></tr></table></figure><p>（或者类似上面这样的），然后当你执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.someProp;</span><br></pre></td></tr></table></figure><p>它检查o是否具有<code>someProp</code>属性。如果没有，它会查找 <code>Object.getPrototypeOf(o).someProp</code>，如果仍旧没有，它会继续查找 <code>Object.getPrototypeOf(Object.getPrototypeOf(o)).someProp</code>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在用原型继承编写复杂代码之前，了解原型继承模型非常<strong>重要</strong>。同时，要注意代码中的原型链的长度，并在必要时将其分解，以避免潜在的性能问题。此外，永远<strong>不要</strong>扩展原生对象的原型，除非是为了兼容新的JavaScript特性。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/d14050d0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>ThreadLocal详解</title>
      <link>https://mliyuanbiao.github.io/post/443887f3.html</link>
      <guid>https://mliyuanbiao.github.io/post/443887f3.html</guid>
      <pubDate>Tue, 10 Oct 2017 04:59:59 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ThreadLocal类位于java.lang包下，jdk1.2开始引入。ThreadLocal为每个使用该类变量的线程提供单独的副本，线程之间不会互相影响。就是说在A线程设置的值只能在A线程读取到，在B线程是读取不到的。</p><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。<br>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>这个类一共提供了四个方法。</p><ul><li><code>set(T value)</code> 将此线程局部变量的当前线程副本中的值设置为指定值。</li><li><code>get()</code>  返回此线程局部变量的当前线程副本中的值。</li><li><code>remove()</code>  移除此线程局部变量当前线程的值。</li><li><code>initialValue()</code> 返回此线程局部变量的当前线程的“初始值”。该实现返回 null；如果程序员希望线程局部变量具有 <code>null</code> 以外的值，则必须为 ThreadLocal <strong>创建子类</strong>，并<strong>重写</strong>此方法。通常将使用<strong>匿名内部类</strong>完成此操作。</li></ul><p>下面看看ThreadLocal是如何解决这一问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">"hello"</span>);</span><br><span class="line">        printValue(); <span class="comment">//打印 main -&gt; hello</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                printValue(); <span class="comment">//打印 Thread-0 -&gt; null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalDemo demo = <span class="keyword">new</span> ThreadLocalDemo();</span><br><span class="line">        demo.test();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//防止程序结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到不同线程获取到的值是不一样的，在主线程设置的值只能在主线程获取到，在子线程返回了一个<code>null</code>。同时把<strong>ThreadLocal</strong>生明为全局变量，也不会影响各线程之间的值。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>下面的代码取自<strong>ThreadLocal</strong>类，展示了最基本的几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个Thread都有自己的ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//在不同线程调用这个方法获取到的ThreadLocalMap对象是不一样的，</span></span><br><span class="line">    <span class="comment">//所以从Map取到的对象更加不可能是一样了。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//用当前对象作为key存储value</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//用当前对象作为key获取value</span></span><br><span class="line">        <span class="comment">//由于是用当前对象作为key，所以一个ThreadLocal对象只能存储一个值。</span></span><br><span class="line">        <span class="comment">//如果想要存储几个值可以多用几个ThreadLocal。</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//用当前对象作为key移除value</span></span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以很容易看出<strong>ThreadLocal</strong>的原理，但是由于<strong>ThreadLocal</strong>的代码太多，这只是很小的一部分，为了便于大家理解问题，我写了一个类模拟<strong>ThreadLocal</strong>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个线程有单独的Map来保证变量在不同线程之间互不影响</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Thread, Map&lt;ThreadLocal, Object&gt;&gt; tMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        Map&lt;ThreadLocal, Object&gt; map = tMap.get(thread);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">            tMap.put(thread, map);</span><br><span class="line">            map.put(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        Map&lt;ThreadLocal, Object&gt; map = tMap.get(thread);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) map.get(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        Map&lt;ThreadLocal, Object&gt; map = tMap.get(thread);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每个<strong>Thread</strong>都有自己的<strong>ThreadLocalMap</strong>，存储<strong>value</strong>的时候会存储到自己的<strong>ThreadLocalMap</strong>，所以在哪个线程设置的<strong>value</strong>就只能在哪个线程获取到，其他<strong>Thread</strong>是获取不到的。因为<strong>ThreadLocal</strong>类用<code>this</code>当做<strong>key</strong>，所以每个<strong>ThreadLocal</strong>最多存储一个<strong>value</strong>。如果想要存储几个值可以多用几个<strong>ThreadLocal</strong>。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/443887f3.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>javascript 模板字符串</title>
      <link>https://mliyuanbiao.github.io/post/7f9876e8.html</link>
      <guid>https://mliyuanbiao.github.io/post/7f9876e8.html</guid>
      <pubDate>Mon, 09 Oct 2017 06:44:25 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string"> string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br><span class="line"></span><br><span class="line">tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 模板字面量也可以使用三元运算符( condition ?  true : false ) 和  嵌套 nested！</p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法(<code>${expression}</code>)的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`\``</span> === <span class="string">"`"</span> <span class="comment">// --&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"string text line 1\n\</span></span><br><span class="line"><span class="string">string text line 2"</span>);</span><br><span class="line"><span class="comment">// "string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2"</span></span><br></pre></td></tr></table></figure><p>要获得同样效果的多行字符串，只需使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// "string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2"</span></span><br></pre></td></tr></table></figure><h3 id="表达式插补"><a href="#表达式插补" class="headerlink" title="表达式插补"></a>表达式插补</h3><p>在普通字符串中嵌入表达式，必须使用如下语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Fifteen is "</span> + (a + b) + <span class="string">" and\nnot "</span> + (<span class="number">2</span> * a + b) + <span class="string">"."</span>);</span><br><span class="line"><span class="comment">// "Fifteen is 15 and</span></span><br><span class="line"><span class="comment">// not 20."</span></span><br></pre></td></tr></table></figure><p>现在通过模板字符串，我们可以使用一种更优雅的方式来表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">$&#123;a + b&#125;</span> and\nnot <span class="subst">$&#123;<span class="number">2</span> * a + b&#125;</span>.`</span>);</span><br><span class="line"><span class="comment">// "Fifteen is 15 and</span></span><br><span class="line"><span class="comment">// not 20."</span></span><br></pre></td></tr></table></figure><h3 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h3><p>模板字符串的一种更高级的形式称为带标签的模板字符串。它允许您通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组（在本例中分别为“Hello”,“world”和””）；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式（在这里分别为“15”和“50”）。 最后，标签函数返回处理好的字符串。在下面的例子中，命名这个标签并没有什么特殊的地方，这个函数的名字可以是任何你想要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings[<span class="number">0</span>]); <span class="comment">// "Hello "</span></span><br><span class="line">  <span class="built_in">console</span>.log(strings[<span class="number">1</span>]); <span class="comment">// " world "</span></span><br><span class="line">  <span class="built_in">console</span>.log(strings[<span class="number">2</span>]); <span class="comment">// ""</span></span><br><span class="line">  <span class="built_in">console</span>.log(values[<span class="number">0</span>]);  <span class="comment">// 15</span></span><br><span class="line">  <span class="built_in">console</span>.log(values[<span class="number">1</span>]);  <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Bazinga!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// "Bazinga!"</span></span><br></pre></td></tr></table></figure><p>正如下面例子所展示的，标签函数并不一定需要返回一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">strings, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dict = values[values.length - <span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> result = [strings[<span class="number">0</span>]];</span><br><span class="line">    keys.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="built_in">Number</span>.isInteger(key) ? values[key] : dict[key];</span><br><span class="line">      result.push(value, strings[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">''</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span><span class="subst">$&#123;<span class="number">1</span>&#125;</span><span class="subst">$&#123;<span class="number">0</span>&#125;</span>!`</span>;</span><br><span class="line">t1Closure(<span class="string">'Y'</span>, <span class="string">'A'</span>);  <span class="comment">// "YAY!" </span></span><br><span class="line"><span class="keyword">var</span> t2Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span> <span class="subst">$&#123;<span class="string">'foo'</span>&#125;</span>!`</span>;</span><br><span class="line">t2Closure(<span class="string">'Hello'</span>, &#123;<span class="attr">foo</span>: <span class="string">'World'</span>&#125;);  <span class="comment">// "Hello World!"</span></span><br></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]); </span><br><span class="line">  <span class="comment">// "string text line 1 \\n string text line 2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`string text line 1 \n string text line 2`</span>;</span><br></pre></td></tr></table></figure><p>另外，使用<code>String.raw()</code>方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// "Hi\\n5!"</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/7f9876e8.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android Studio 自动检查依赖库是否有新版本</title>
      <link>https://mliyuanbiao.github.io/post/f7a3c6c0.html</link>
      <guid>https://mliyuanbiao.github.io/post/f7a3c6c0.html</guid>
      <pubDate>Tue, 12 Sep 2017 07:45:32 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;strong&gt;Preferences&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Editor&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Inspections&lt;/strong&gt; -&amp;gt; “&lt;strong&gt;Android &amp;gt; Lint &amp;gt;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>Preferences</strong> -&gt; <strong>Editor</strong> -&gt; <strong>Inspections</strong> -&gt; “<strong>Android &gt; Lint &gt; Correctness</strong>” -&gt; <strong>Newer Library Versions Available (available for Analyze|Inspect Code)</strong>    <font color="red"><strong>这一项打上勾</strong></font>。<br><img src="/media/15051956933872/15051957572874.png" alt=""></p><p>如果想要检查的话，同时按住 <strong>shift+alt+command+i</strong> ，会弹出 <strong>Enter Inspect name</strong> 窗口。输入 <strong>Newer Library Versions Available</strong> ，一般不用输入全部的，输入 <strong>Newer</strong> 就好了，包含 <strong>Newer</strong> 的选项就会全部搜索出来。<br><img src="/media/15051956933872/15051957698386.png" alt=""></p><p>选择 <strong>Newer Library Versions Available</strong> 这一项<br><img src="/media/15051956933872/15051957934804.png" alt=""></p><p>选择你需要检查的模块</p><ul><li><strong>Whole project</strong>  -&gt;完整的模块。 </li><li><strong>Module</strong> -&gt; 单独的一个模块</li><li><strong>File</strong> -&gt; 单独的一个文件</li><li><strong>Custom scope</strong> -&gt; 自定义范围</li></ul><p>我这里选择 <strong>Whole project</strong> ，点击 <strong>OK</strong> 就可以开始检查了。<br><img src="/media/15051956933872/15051958715001.jpg" alt=""></p><p>点击 <strong>Update to [VersionName]</strong> 就可以把版本号替换到最新版本。<br>最后点击 <strong>Sync Now</strong> 同步一下项目<br><img src="/media/15051956933872/15051961312946.jpg" alt=""></p><p>需要注意升级版本后，新版本可能不兼容旧版本，需要仔细检查代码，防止出错。</p>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/f7a3c6c0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android记录器Logger</title>
      <link>https://mliyuanbiao.github.io/post/de93668b.html</link>
      <guid>https://mliyuanbiao.github.io/post/de93668b.html</guid>
      <pubDate>Fri, 08 Sep 2017 14:16:24 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;Logger&quot;&gt;&lt;a href=&quot;#Logger&quot; class=&quot;headerlink&quot; title=&quot;Logger&quot;&gt;&lt;/a&gt;Logger&lt;/h1&gt;&lt;p&gt;简单，漂亮，功能强大的Android记录器&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h1><p>简单，漂亮，功能强大的Android记录器</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.orhanobut:logger:2.2.0'</span></span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.addLogAdapter(<span class="keyword">new</span> AndroidLogAdapter());</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.d(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><img src="/media/15337379282287.jpg" alt=""></p><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Logger.d(<span class="string">"debug"</span>);</span><br><span class="line">Logger.e(<span class="string">"error"</span>);</span><br><span class="line">Logger.w(<span class="string">"warning"</span>);</span><br><span class="line">Logger.v(<span class="string">"verbose"</span>);</span><br><span class="line">Logger.i(<span class="string">"information"</span>);</span><br><span class="line">Logger.wtf(<span class="string">"What a Terrible Failure"</span>);</span><br></pre></td></tr></table></figure><p>支持字符串格式参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.d(<span class="string">"hello %s"</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>支持集合（仅适用于调试日志）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Logger.d(MAP);</span><br><span class="line">Logger.d(SET);</span><br><span class="line">Logger.d(LIST);</span><br><span class="line">Logger.d(ARRAY);</span><br></pre></td></tr></table></figure><p>Json和Xml支持（输出将处于调试级别）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger.json(JSON_CONTENT);</span><br><span class="line">Logger.xml(XML_CONTENT);</span><br></pre></td></tr></table></figure><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder()</span><br><span class="line">  .showThreadInfo(<span class="keyword">false</span>)  <span class="comment">// (可选) 是否显示线程信息。默认为true</span></span><br><span class="line">  .methodCount(<span class="number">0</span>)         <span class="comment">// (可选) 要显示多少个方法行。默认2</span></span><br><span class="line">  .methodOffset(<span class="number">7</span>)        <span class="comment">// (可选) 隐藏内部方法调用以抵消偏移。默认5</span></span><br><span class="line">  .logStrategy(customLog) <span class="comment">// (可选) 更改打印日志策略。默认LogCat</span></span><br><span class="line">  .tag(<span class="string">"My custom tag"</span>)   <span class="comment">// (可选) 每个日志的全局TAG。默认“PRETTY_LOGGER”</span></span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">Logger.addLogAdapter(<span class="keyword">new</span> AndroidLogAdapter(formatStrategy));</span><br></pre></td></tr></table></figure><h2 id="可打印"><a href="#可打印" class="headerlink" title="可打印"></a>可打印</h2><p>日志适配器通过检查此功能来检查是否应打印日志。如果要禁用/隐藏输出日志，请覆盖isLoggable方法。 true将打印日志消息，false将忽略它。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Logger.addLogAdapter(<span class="keyword">new</span> AndroidLogAdapter() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">(<span class="keyword">int</span> priority, String tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="将日志保存到文件中"><a href="#将日志保存到文件中" class="headerlink" title="将日志保存到文件中"></a>将日志保存到文件中</h2><p>// TODO：稍后会添加更多信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.addLogAdapter(<span class="keyword">new</span> DiskLogAdapter());</span><br></pre></td></tr></table></figure><p>将自定义 TAG 添加到Csv格式策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FormatStrategy formatStrategy = CsvFormatStrategy.newBuilder()</span><br><span class="line">  .tag(<span class="string">"custom"</span>)</span><br><span class="line">  .build();</span><br><span class="line">  </span><br><span class="line">Logger.addLogAdapter(<span class="keyword">new</span> DiskLogAdapter(formatStrategy));</span><br></pre></td></tr></table></figure><h2 id="怎么运行的"><a href="#怎么运行的" class="headerlink" title="怎么运行的"></a>怎么运行的</h2><p><img src="/media/15337379584559.jpg" alt=""></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ul><li>使用过滤器可获得更好的效果。 PRETTY_LOGGER或您的自定义标记</li><li>确保禁用换行选项</li><li>您还可以通过更改设置来简化输出</li></ul><p><img src="/media/15337379723935.jpg" alt=""></p><ul><li>Timber Integration</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将methodOffset设置为5以隐藏内部方法调用</span></span><br><span class="line">Timber.plant(<span class="keyword">new</span> Timber.DebugTree() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> priority, String tag, String message, Throwable t)</span> </span>&#123;</span><br><span class="line">    Logger.log(priority, tag, message, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://mliyuanbiao.github.io/post/de93668b.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
