<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>我的个人博客</title>
    <link>https://liyuanbiao100.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>知识整理</description>
    <pubDate>Thu, 23 Nov 2017 14:15:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android Handler机制详解</title>
      <link>https://liyuanbiao100.github.io/2017/11/23/Android-Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://liyuanbiao100.github.io/2017/11/23/Android-Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Thu, 23 Nov 2017 08:05:12 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Handler</code>是Android的消息机制，他能够很轻松的在线程间传递数据。由于Android开发规范的限制，我们不能在主线程执行耗时操作（如网络，IO操作等），不能在子线程更新UI，所以<code>Handler</code>大部分用来在耗时操作与更新UI之间切换。这让很多人误以为<code>Handler</code>就是用来更新UI的，其实这只是它的一小部分应用。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我相信大多数人对<code>Handler</code>的用法已经烂熟于心了，这篇文章不会去探讨<code>Handler</code>的使用，而是着重从源码上分析<code>Handler</code>的运行机制。</p><p>想要了解<code>Handler</code>的运行机制，我们需要了解 <code>MessageQueue</code> ，<code>Message</code>，<code>Looper</code> 这几个类。</p><ul><li><code>MessageQueue</code> 的意思就是消息队列，它存储了我们需要用来处理的消息<code>Message</code>。</li><li><code>Message</code>是消息类，内部存在一个<code>Bundle</code>对象和几个<code>public</code>字段存储数据，<code>MessageQueue</code>作为一个消息队列不能自己处理消息，所以需要用到<code>Looper</code>。</li><li><code>Looper</code>是一个循环装置，他负责从不断从<code>MessageQueue</code>里取出<code>Message</code>，然后回调给<code>Handler</code>的<code>handleMessage</code>来执行具体操作。</li><li><code>Handler</code>在这里面充当的角色更像是一个辅助类，它让我们不用关系<code>MessageQueue</code>和<code>Looper</code>的具体细节，只需要关系如何发送消息和回调的处理就行了。</li></ul><p>上面讲了几个关键类在<code>Handler</code>运行机制中的职责，相对大家对Handler机制有个粗略的了解。</p><p>我相信各位看官在阅读这篇文章前都是带着问题的，我们将通过问题来解答大家的疑惑。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>在分析<code>Looper</code>之前，我们还需要知道<code>ThreadLocal</code>这个类，如果对<code>ThreadLocal</code>还不太了解，可以去看我的另一篇文章<a href="/2017/10/10/ThreadLocal详解/">《ThreadLocal详解》</a>。</p><h5 id="Looper是如何创建？"><a href="#Looper是如何创建？" class="headerlink" title="Looper是如何创建？"></a>Looper是如何创建？</h5><p><code>Handler</code>执行的线程和它持有的<code>Looper</code>有关。每个<code>Thread</code>都可以创建唯一的Looper对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为当前线程创建Looper对象的方法。</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">       prepare(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">   <span class="comment">//使用ThreadLocal来存储当前线程的Looper对象，这保证了每个线程有且仅有一个Looper对象。</span></div><div class="line">   <span class="comment">//这里做了非空判断，所以在同一个线程prepare方法是不允许被调用两次的</span></div><div class="line">   <span class="comment">//第一次创建好的Looper对象不会被覆盖，它是唯一的。</span></div><div class="line">       <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">       &#125;</div><div class="line">       sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>那么主线程的<code>Looper</code>对象是怎么创建的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//其实主线程创建Looper和其他线程没有区别，也是调用prepare()。</span></div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//但是Looper用sMainLooper这个静态变量将主线程的Looper对象存储了起来</span></div><div class="line">            <span class="comment">//可以通过getMainLooper()获取，存储MainLooper其实非常有作用，下面会讲到。</span></div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">return</span> sMainLooper;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h5 id="Looper是如何从MessageQueue取出消息并分发的？"><a href="#Looper是如何从MessageQueue取出消息并分发的？" class="headerlink" title="Looper是如何从MessageQueue取出消息并分发的？"></a>Looper是如何从MessageQueue取出消息并分发的？</h5><p>Looper分发消息的主要逻辑在loop方法里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Run the message queue in this thread. Be sure to call</span></div><div class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">       <span class="comment">//保证当前线程必须有Looper对象，如果没有则抛出异常，调用Looper.loop()之前应该先调用Looper.prepare().</span></div><div class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//Looper需要不断从MessageQueue中取出消息，所以它持有MessageQueue对象</span></div><div class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">       <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">       <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">       Binder.clearCallingIdentity();</div><div class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">          <span class="comment">//这里开始执行死循环，queue通过调用next方法来取出下一个消息。</span></div><div class="line">          <span class="comment">//很多人很疑惑死循环不会相当耗费性能吗，如果没有那么多消息怎么办？</span></div><div class="line">          <span class="comment">//其实当没有消息的时候，next方法会阻塞在这里，不会往下执行了，性能问题不存在。</span></div><div class="line">           Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">               <span class="comment">//这里满足了死循环跳出的条件，即取出的消息为null</span></div><div class="line">               <span class="comment">//没有消息next不是会阻塞吗，怎么会返回null呢？</span></div><div class="line">               <span class="comment">//其实只有MessageQueue停止的时候（调用quit方法），才会返回null</span></div><div class="line">               <span class="comment">//MessageQueue停止后，调用next返回null，且不再接受新消息，下面还有详细介绍。</span></div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">           Printer logging = me.mLogging;</div><div class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">               logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                       msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">//这里的msg.target是Handler对象，分发消息到Handler去执行。</span></div><div class="line">           <span class="comment">//有人问主线程可以创建这么多Handler，怎么保证这个Handler发送的消息不会跑到其它Handler去执行呢？</span></div><div class="line">           <span class="comment">//那是因为在发送Message时，他会绑定发送的Handler，在此处分发消息时，也只会回调发送该条消息的Handler。</span></div><div class="line">           <span class="comment">//那么分发消息具体在哪个线程执行呢？</span></div><div class="line">           <span class="comment">//我觉得这个不该问，那当然是当前方法在哪个线程调用就在哪个线程执行啦。</span></div><div class="line">           msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">               logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">           <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">           <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">           <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">               Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                       + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                       + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                       + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                       + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       <span class="comment">//这里对Message对象进行回收，会清空所有之前Message设置的数据。</span></div><div class="line">       <span class="comment">//正是因为Message有回收机制，我们在创建消息的时候应该优先选择Message.obtain(). </span></div><div class="line">       <span class="comment">//如果发送的消息足够多，Message缓存的Message对象不够了，obtain内部会调用new Message()创建一个新的对象。</span></div><div class="line">           msg.recycleUnchecked();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h5 id="Looper-分发的消息在哪个线程执行？"><a href="#Looper-分发的消息在哪个线程执行？" class="headerlink" title="Looper 分发的消息在哪个线程执行？"></a>Looper 分发的消息在哪个线程执行？</h5><p>先给大家展示一段<code>Looper</code>文档上的示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> Handler mHandler;</div><div class="line">  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper.prepare(); <span class="comment">//创建LooperThread的Looper对象</span></div><div class="line">  </div><div class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">              <span class="comment">//处理发送过来的消息</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    </div><div class="line">        Looper.loop(); <span class="comment">//开始循环消息队列</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这段代码相信很多人都写过，这是一段在子线程创建Handler的案例，其中<code>handleMessage</code>所执行的线程为<code>LooperThread</code>，因为<code>Looper.loop()</code>执行在<code>LooperThread</code>的<code>run</code>方法里。可以在其他线程通过<code>mHandler</code>发送消息到<code>LooperThread</code></p><h5 id="如果不调用Looper-prepare-直接new-Handler-会怎么样呢？"><a href="#如果不调用Looper-prepare-直接new-Handler-会怎么样呢？" class="headerlink" title="如果不调用Looper.prepare()直接new Handler()会怎么样呢？"></a>如果不调用<code>Looper.prepare()</code>直接<code>new Handler()</code>会怎么样呢？</h5><p>我们可以查看<code>Handler</code>的源码看看无参构造是如何运行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//调用两参构造</span></div><div class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//获取当前线程的Looper，如果不创建Looper会抛出异常。</span></div><div class="line"><span class="comment">//主线程我也没看到有调用Looper.prepare()啊，怎么在主线程不会抛异常呢？这个看下一个问题。</span></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="主线程的Looper对象在哪里创建的？"><a href="#主线程的Looper对象在哪里创建的？" class="headerlink" title="主线程的Looper对象在哪里创建的？"></a>主线程的Looper对象在哪里创建的？</h5><p>从上一个问题可以看出如果不调用<code>Looper.prepare()</code>直接<code>new Handler()</code>就会抛出异常` </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);`</div></pre></td></tr></table></figure><p>那么主线程的<code>Looper</code>在哪里创建的呢？首先它是创建了的，因为<code>Looper.getMainLooper() != null</code>，其实<code>MainLooper</code>创建的时间比我们想象的早，它在<code>ActivityThread</code>类里面，<code>ActivityThread</code>是<code>Android</code>的启动类，<code>main</code>方法就在里面（如果有人问你Android有没有main方法，你应该知道怎么回答了吧），而<code>MainLooper</code>就是在<code>main</code>方法里面创建的。</p><p>上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//android.app.ActivityThread</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         </div><div class="line">        SamplingProfilerIntegration.start();</div><div class="line">    </div><div class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</div><div class="line">    </div><div class="line">        Environment.initForCurrentUser();</div><div class="line">    </div><div class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line">    </div><div class="line">        Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</div><div class="line">    </div><div class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></div><div class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</div><div class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</div><div class="line">    </div><div class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line">    </div><div class="line">        <span class="comment">//注意这里，这里创建了主线程的Looper</span></div><div class="line">        Looper.prepareMainLooper();</div><div class="line">    </div><div class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">        thread.attach(<span class="keyword">false</span>);</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        AsyncTask.init();</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//开启消息循环</span></div><div class="line">        Looper.loop();</div><div class="line">    </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="MainLooper可以用来做什么"><a href="#MainLooper可以用来做什么" class="headerlink" title="MainLooper可以用来做什么"></a>MainLooper可以用来做什么</h5><h6 id="判断当前线程是否为主线程"><a href="#判断当前线程是否为主线程" class="headerlink" title="判断当前线程是否为主线程"></a>判断当前线程是否为主线程</h6><p>因为Looper是在某一线程唯一的，那么可以在么做。如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//如果当前线程的Looper和MainLooper是同一个对象，那么可以认为当前线程是主线程</span></div><div class="line">        <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper() ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是也有人说下面这样也可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//这个方法其实是不准确的，线程的名称是可以随便更改的。</span></div><div class="line">    <span class="keyword">return</span> Thread.currentThread().getName().equals(<span class="string">"main"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以用<code>Looper</code>来判断主线程是很好的做法</p><h6 id="创建运行在主线程的Handler"><a href="#创建运行在主线程的Handler" class="headerlink" title="创建运行在主线程的Handler"></a>创建运行在主线程的Handler</h6><p><code>Handler</code>除了有无参构造，还有一个可以传入<code>Looper</code>的构造。通过指定<code>Looper</code>，可以在任意地方创建运行在主线程的<code>Handler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Handler mHandler;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">                <span class="comment">//运行在主线程</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        mHandler.sendEmptyMessage(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="Looper的quit方法和quitSafely方法有什么区别"><a href="#Looper的quit方法和quitSafely方法有什么区别" class="headerlink" title="Looper的quit方法和quitSafely方法有什么区别"></a>Looper的quit方法和quitSafely方法有什么区别</h5><p>下面是<code>Looper</code>两个方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出实际上是调用的<code>MessageQueue</code>的<code>quit</code>方法<br>下面是<code>MessageQueue</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//android.os.MessageQueue</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mQuitting = <span class="keyword">true</span>;</div><div class="line">            <span class="comment">//如果调用的是quitSafely运行removeAllFutureMessagesLocked，否则removeAllMessagesLocked。</span></div><div class="line">            <span class="keyword">if</span> (safe) &#123;</div><div class="line">            <span class="comment">//该方法只会清空MessageQueue消息池中所有的延迟消息，</span></div><div class="line">            <span class="comment">//并将消息池中所有的非延迟消息派发出去让Handler去处理，</span></div><div class="line">            <span class="comment">//quitSafely相比于quit方法安全之处在于清空消息之前会派发所有的非延迟消息。</span></div><div class="line">                removeAllFutureMessagesLocked();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//该方法的作用是把MessageQueue消息池中所有的消息全部清空，</span></div><div class="line">            <span class="comment">//无论是延迟消息（延迟消息是指通过sendMessageDelayed或通过postDelayed等方法发送的需要延迟执行的消息）还是非延迟消息。</span></div><div class="line">                removeAllMessagesLocked();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>无论是调用了<code>quit</code>方法还是<code>quitSafely</code>方法，<code>MessageQueue</code>将不再接收新的<code>Message</code>，此时消息循环就结束，<code>MessageQueued</code>的<code>next</code>方法将返回<code>null</code>，结束<code>loop()</code>的死循环.这时候再通过<code>Handler</code>调用<code>sendMessage</code>或<code>post</code>等方法发送消息时均返回<code>false</code>，表示消息没有成功放入消息队列<code>MessageQueue</code>中，因为消息队列已经退出了。</p><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><h5 id="Message-obtain-和new-Message-如何选择"><a href="#Message-obtain-和new-Message-如何选择" class="headerlink" title="Message.obtain()和new Message()如何选择"></a>Message.obtain()和new Message()如何选择</h5><p><code>Message</code>提供了<code>obtain</code>等多个重载的方法来创建<code>Message</code>对象，那么这种方式和直接<code>new</code>该如何选择。下面看看<code>obtain</code>的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = <span class="keyword">null</span>;</div><div class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></div><div class="line">            sPoolSize--;</div><div class="line">            <span class="keyword">return</span> m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">//只有当从对象池里取不出Message才去new</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//清除所有使用过的痕迹</span></div><div class="line">        flags = FLAG_IN_USE;</div><div class="line">        what = <span class="number">0</span>;</div><div class="line">        arg1 = <span class="number">0</span>;</div><div class="line">        arg2 = <span class="number">0</span>;</div><div class="line">        obj = <span class="keyword">null</span>;</div><div class="line">        replyTo = <span class="keyword">null</span>;</div><div class="line">        sendingUid = -<span class="number">1</span>;</div><div class="line">        when = <span class="number">0</span>;</div><div class="line">        target = <span class="keyword">null</span>;</div><div class="line">        callback = <span class="keyword">null</span>;</div><div class="line">        data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//回收到对象池</span></div><div class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">                next = sPool;</div><div class="line">                sPool = <span class="keyword">this</span>;</div><div class="line">                sPoolSize++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>从上面代码可以看出，通过<code>obtain</code>方法是从对象池取，而<code>new</code>是创建了一个新的对象。我们应该使用<code>obtain</code>来创建<code>Message</code>对象，每次使用完后都会自动进行回收，节省内存。</p><p>未完待续……</p>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/11/23/Android-Handler%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android应用内安装App的几种姿势</title>
      <link>https://liyuanbiao100.github.io/2017/10/27/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AE%89%E8%A3%85App%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/27/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AE%89%E8%A3%85App%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/</guid>
      <pubDate>Fri, 27 Oct 2017 09:16:58 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h4 id=&quot;调用系统安装程序&quot;&gt;&lt;a href=&quot;#调用系统安装程序&quot; class=&quot;headerlink&quot; title=&quot;调用系统安装程序&quot;&gt;&lt;/a&gt;调用系统安装程序&lt;/h4&gt;&lt;p&gt;这种方式最为简单，只需要调起系统界面即可。看代码&lt;/p&gt;
&lt;figure
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="调用系统安装程序"><a href="#调用系统安装程序" class="headerlink" title="调用系统安装程序"></a>调用系统安装程序</h4><p>这种方式最为简单，只需要调起系统界面即可。看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 调用系统安装界面</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> apkFile</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startInstallActivity</span><span class="params">(Context context, File apkFile)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (apkFile == <span class="keyword">null</span> || !apkFile.exists()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</div><div class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">    intent.setDataAndType(Uri.parse(<span class="string">"file://"</span> + apkFile.toString()), <span class="string">"application/vnd.android.package-archive"</span>);</div><div class="line">    context.startActivity(intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="调用系统pm命令"><a href="#调用系统pm命令" class="headerlink" title="调用系统pm命令"></a>调用系统pm命令</h4><p>这种方式是在通过终端执行<em>pm</em>命令来实现 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm install -r [filepath]</div></pre></td></tr></table></figure><p>其中<code>-r</code>代表覆盖安装。<br>这种方式可以实现静默安装，不需要调起系统界面。但是有一个前提，就是需要<em>root</em>权限，没有去<em>root</em>权限，<em>pm</em>命令不能执行。获取<em>root</em>权限不是本文范畴，请自行百度或者google。</p><p>满足前提的情况下，我们可能用到以下方法。</p><ul><li>判断设备是否有root权限,通过执行su命令是否正确来检查设备是否被root</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 检查设备是否被root</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span></span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRoot</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Process process = Runtime.getRuntime().exec(<span class="string">"su"</span>);</div><div class="line">        process.getOutputStream().write(<span class="string">"exit\n"</span>.getBytes());</div><div class="line">        process.getOutputStream().flush();</div><div class="line">        <span class="keyword">int</span> i = process.waitFor();</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">            process = Runtime.getRuntime().exec(<span class="string">"su"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>执行终端命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行终端命令</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> cmd</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">execRootCmdSilent</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</div><div class="line">        DataOutputStream dos = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Process p = Runtime.getRuntime().exec(<span class="string">"su"</span>);</div><div class="line">            dos = <span class="keyword">new</span> DataOutputStream(p.getOutputStream());</div><div class="line">            Log.i(TAG, cmd);</div><div class="line">            dos.writeBytes(cmd + <span class="string">"\n"</span>);</div><div class="line">            dos.flush();</div><div class="line">            dos.writeBytes(<span class="string">"exit\n"</span>);</div><div class="line">            dos.flush();</div><div class="line">            p.waitFor();</div><div class="line">            result = p.exitValue();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    dos.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li>安装apk，在终端执行 <code>pm install -r filePath</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installApk</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (TextUtils.isEmpty(filePath) || !<span class="keyword">new</span> File(filePath).exists()) <span class="keyword">return</span>;</div><div class="line">   execRootCmdSilent(<span class="string">"pm install -r "</span> + filePath);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="反射PackageManager的installPackage方法"><a href="#反射PackageManager的installPackage方法" class="headerlink" title="反射PackageManager的installPackage方法"></a>反射<em>PackageManager</em>的<em>installPackage</em>方法</h4><p>通过查看查看系统安装程序的源码，可以看到系统安装程序实际上是调用<em>PackageManager</em>的<em>installPackage</em>方法来实现安装的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@deprecated</span> replaced by &#123;<span class="doctag">@link</span> PackageInstaller&#125;</span></div><div class="line"><span class="comment">     * <span class="doctag">@hide</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">installPackage</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            Uri packageURI, //APK地址</span></span></div><div class="line"><span class="function"><span class="params">            IPackageInstallObserver observer, //安装回调</span></span></div><div class="line"><span class="function"><span class="params">            @InstallFlags <span class="keyword">int</span> flags,</span></span></div><div class="line"><span class="function"><span class="params">            String installerPackageName)</span></span>; <span class="comment">//被安装APK的包名</span></div></pre></td></tr></table></figure><ul><li><p><em>installPackage</em>方法虽然是<em>public</em>修饰的，但是同时被<em>@hide</em>了，所以应用程序无法直接调用，这就需要用到反射机制了。</p></li><li><p>调用这个方法需要系统权限，所以需要用系统签名对apk打包，具体操作可以参考<a href="http://connorlin.github.io/2016/04/27/让Android-Studio支持系统签名&#40;证书&#41;" target="_blank" rel="external">这篇文章</a></p></li><li><p><em>IPackageInstallObserver</em>是一个<em>AIDL</em>接口，所以我们需要用到<em>IPackageInstallObserver.aidl</em> 这个文件。你可以</p><ul><li><p>直接从系统源码拷贝，该文件位于<code>/frameworks/base/core/java/android/content/pm</code></p></li><li><p>或者拷贝我的，在你的项目下创建<code>app/src/main/aidl/android/content/pm/IPackageInstallObserver.aidl</code>文件，然后将下面的代码复制进去</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> android.content.pm;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * API for installation callbacks from the Package Manager.</span></div><div class="line"><span class="comment"> * <span class="doctag">@hide</span></span></div><div class="line"><span class="comment"> */</span></div><div class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IPackageInstallObserver</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">packageInstalled</span><span class="params">(in String packageName, <span class="keyword">int</span> returnCode)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当上述都做好了之后。</p><ul><li>调用安装的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//installPackage方法名</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTALL_METHOD = <span class="string">"installPackage"</span>;</div><div class="line"></div><div class="line"><span class="comment">//InstallFlags</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORWARD_LOCK = <span class="number">0x00000001</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_REPLACE_EXISTING = <span class="number">0x00000002</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_ALLOW_TEST = <span class="number">0x0000000</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_EXTERNAL = <span class="number">0x00000008</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_INTERNAL = <span class="number">0x00000010</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FROM_ADB = <span class="number">0x00000020</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_ALL_USERS = <span class="number">0x00000040</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_ALLOW_DOWNGRADE = <span class="number">0x00000080</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_GRANT_RUNTIME_PERMISSIONS = <span class="number">0x00000100</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORCE_VOLUME_UUID = <span class="number">0x00000200</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORCE_PERMISSION_PROMPT = <span class="number">0x00000400</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_EPHEMERAL = <span class="number">0x00000800</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_DONT_KILL_APP = <span class="number">0x00001000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FORCE_SDK = <span class="number">0x00002000</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONT_KILL_APP = <span class="number">0x00000001</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installPackage</span><span class="params">(Context context, File file, IPackageInstallObserver observer)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</div><div class="line">    PackageManager packageManager = context.getPackageManager();</div><div class="line">    Method method = PackageManager.class.getDeclaredMethod(INSTALL_METHOD, Uri.class,</div><div class="line">            IPackageInstallObserver.class, <span class="keyword">int</span>.class, String.class);</div><div class="line">    method.invoke(packageManager, Uri.fromFile(file), observer, INSTALL_REPLACE_EXISTING | INSTALL_DONT_KILL_APP, GetAppInfo.getAPKPackageName(context, file.getAbsolutePath()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>监听安装回调</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//安装回调</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageInstallObserver</span> <span class="keyword">extends</span> <span class="title">IPackageInstallObserver</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">packageInstalled</span><span class="params">(String packageName, <span class="keyword">int</span> returnCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(returnCode == INSTALL_SUCCEEDED)&#123;</div><div class="line">            <span class="comment">//安装成功</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//returnCode的取值</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_SUCCEEDED = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_ALREADY_EXISTS = -<span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INVALID_APK = -<span class="number">2</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INVALID_URI = -<span class="number">3</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INSUFFICIENT_STORAGE = -<span class="number">4</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_DUPLICATE_PACKAGE = -<span class="number">5</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_NO_SHARED_USER = -<span class="number">6</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_UPDATE_INCOMPATIBLE = -<span class="number">7</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_SHARED_USER_INCOMPATIBLE = -<span class="number">8</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_MISSING_SHARED_LIBRARY = -<span class="number">9</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_REPLACE_COULDNT_DELETE = -<span class="number">10</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_DEXOPT = -<span class="number">11</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_OLDER_SDK = -<span class="number">12</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_CONFLICTING_PROVIDER = -<span class="number">13</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_NEWER_SDK = -<span class="number">14</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_TEST_ONLY = -<span class="number">15</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -<span class="number">16</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_MISSING_FEATURE = -<span class="number">17</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_CONTAINER_ERROR = -<span class="number">18</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INVALID_INSTALL_LOCATION = -<span class="number">19</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_MEDIA_UNAVAILABLE = -<span class="number">20</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_VERIFICATION_TIMEOUT = -<span class="number">21</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_VERIFICATION_FAILURE = -<span class="number">22</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_PACKAGE_CHANGED = -<span class="number">23</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_UID_CHANGED = -<span class="number">24</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_VERSION_DOWNGRADE = -<span class="number">25</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE = -<span class="number">26</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_NOT_APK = -<span class="number">100</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_BAD_MANIFEST = -<span class="number">101</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION = -<span class="number">102</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_NO_CERTIFICATES = -<span class="number">103</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES = -<span class="number">104</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING = -<span class="number">105</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME = -<span class="number">106</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID = -<span class="number">107</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_MANIFEST_MALFORMED = -<span class="number">108</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PARSE_FAILED_MANIFEST_EMPTY = -<span class="number">109</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_INTERNAL_ERROR = -<span class="number">110</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_USER_RESTRICTED = -<span class="number">111</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_DUPLICATE_PERMISSION = -<span class="number">112</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_NO_MATCHING_ABIS = -<span class="number">113</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_NATIVE_LIBRARIES = -<span class="number">114</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_FAILED_ABORTED = -<span class="number">115</span>;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/27/Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AE%89%E8%A3%85App%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何理解Kotlin中属性</title>
      <link>https://liyuanbiao100.github.io/2017/10/27/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Kotlin%E4%B8%AD%E5%B1%9E%E6%80%A7/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/27/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Kotlin%E4%B8%AD%E5%B1%9E%E6%80%A7/</guid>
      <pubDate>Fri, 27 Oct 2017 07:59:12 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;属性的定义&quot;&gt;&lt;a href=&quot;#属性的定义&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h2><p>在<strong>kotlin</strong>中，<strong>var</strong>和<strong>val</strong>是用来声明属性的两个关键字，在<strong>kotlin</strong>官方参考文档上是这么说的。</p><blockquote><p><strong>Kotlin</strong>的类可以有属性。 属性可以用关键字 <strong>var</strong>声明为可变的，否则使用只读关键字<strong>val</strong>。</p></blockquote><p>那什么是可变属性，什么又是可读属性呢？我们在问这个问题前可以先回顾一下java对属性的定义。</p><blockquote><p>属性可以通过<strong>get</strong>、<strong>set</strong>、<strong>is</strong>（可以替代<strong>get</strong>，用在布尔型属性上）方法或遵循特定命名规范的其他方法访问。</p></blockquote><p>在这里我们可以理解为，在<strong>java</strong>中，对一个字段生成<strong>public</strong>的<strong>set get</strong>方法，那么他就是一个可变（可读可写）属性，仅提供<strong>public get</strong>或者<strong>set</strong>被<strong>private</strong>修饰的就是一个只读属性。</p><p>在kotlin中我们是如何定义属性的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">//定义一个String类型的属性name</span></div><div class="line">    var name: String? = <span class="keyword">null</span></div><div class="line">    <span class="comment">//定义一个Boolean类型的属性deceased</span></div><div class="line">    var deceased: Boolean? = <span class="keyword">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>kotlin和java同属于jvm语言，编译后会生成class文件。我将上面的kotlin代码生成的class再次反编译成java代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">   <span class="meta">@Nullable</span></div><div class="line">   <span class="keyword">private</span> String name;</div><div class="line">   <span class="meta">@Nullable</span></div><div class="line">   <span class="keyword">private</span> Boolean deceased = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">   <span class="meta">@Nullable</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(@Nullable String var1)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.name = var1;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Nullable</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Boolean <span class="title">getDeceased</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.deceased;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDeceased</span><span class="params">(@Nullable Boolean var1)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.deceased = var1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看到这里你会发现，反编译后代码和java属性的定义是一毛一样有木有。所以<strong>kotlin</strong>的属性，在<strong>java</strong>代码中可以通过<strong>set get</strong>方法来调用。</p><h2 id="只读属性和常量"><a href="#只读属性和常量" class="headerlink" title="只读属性和常量"></a>只读属性和常量</h2><p>有的地方说，<strong>var</strong>是声明变量的，<strong>val</strong>是声明常量的。这个其实不是完全正确，至少<strong>val</strong>在官方参考文档上说的是只读属性，而不是常量。比方说温度，我们可以获取温度的变化，但是不能人为直接改变温度，那么温度就是只读属性，而不是常量。<br>再比如说list的isEmpty属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isEmpty <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></div></pre></td></tr></table></figure><p>isEmpty属性受到size的改变而改变，但是无法主动去设置isEmpty的值。那么isEmpty就是个只读属性。</p><p>在这里要分为几种情况来理解<strong>val</strong>。</p><ul><li><strong>val</strong>声明的属性被字面量或者表达式赋值的时候</li><li><strong>val</strong>声明的属性实现了自定义的<strong>get</strong>方法</li></ul><p>看下面的例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">//这里的name属性被字面量“zhangsan”赋值了</span></div><div class="line">    <span class="keyword">val</span> name: String? = <span class="string">"zhangsan"</span></div><div class="line">     <span class="comment">//age属性的值受birthday的影响</span></div><div class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123;</div><div class="line">        <span class="keyword">return</span> Calendar.getInstance().<span class="keyword">get</span>(Calendar.YEAR) - birthday</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> birthday: <span class="built_in">Int</span> = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 反编译成<strong>java</strong>代码是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="comment">//name属性被字面量赋值，编译后会加上final关键字，成为真正的常量</span></div><div class="line">   <span class="meta">@Nullable</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">"zhangsan"</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> birthday;</div><div class="line"></div><div class="line">   <span class="meta">@Nullable</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//age属性只实现了get方法，无法通过set方法来改变值，是个只读属性</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> Calendar.getInstance().get(<span class="number">1</span>) - <span class="keyword">this</span>.birthday;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.birthday;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.birthday = var1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="什么是变量的幕后字段"><a href="#什么是变量的幕后字段" class="headerlink" title="什么是变量的幕后字段"></a>什么是变量的幕后字段</h2><p>在<strong>kotlin</strong>中可以通过关键字声明属性，那可不可以声明字段呢？它有没有字段呢？<br>答：<strong>kotlin</strong>中不能声明字段，但是<strong>kotlin</strong>中是有字段的，他有一个幕后字段的概念，每一个属性可以有一个幕后字段，也可以没有。</p><p>拿上面的例子再讲一遍</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> isEmpty <span class="keyword">get</span>() = <span class="keyword">this</span>.size == <span class="number">0</span></div></pre></td></tr></table></figure><p>isEmpty的值只和size有关，那么在反编译之后，不会出现如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">false</span>;</div></pre></td></tr></table></figure><p>这里可以得出一个结论，属性不一定非得有字段。对<strong>java</strong>属性定义的后半句是这么说的，“<em>或遵循特定命名规范的其他方法访问</em>”，所以关键看方法的定义，比如说在一个类里面有<strong>setWidth()</strong>,<strong>getWidth()</strong>这两个方法。就可以认定为这个类有<strong>width</strong>属性，但是不一定有<strong>width</strong>这个字段。</p><p>也就是说这个属性没有幕后字段。</p><p>再看下面这个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//name属性没有实现自定义的set get方法</span></div><div class="line"><span class="keyword">var</span> name:String? = <span class="literal">null</span>;</div><div class="line">......</div><div class="line"></div><div class="line">name = <span class="string">"zhangsan"</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> len = name.length()</div></pre></td></tr></table></figure><p><strong>name</strong>没有实现自定义的<strong>set get</strong>方法，字面值”zhangsan”需要一个字段来赋值。那么在class里面会生成 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个就是name属性的幕后字段</span></div><div class="line"><span class="keyword">private</span> String name = <span class="keyword">null</span>;</div></pre></td></tr></table></figure><p>那么幕后字段可以用代码访问到么，这个是可以的，使用 <strong>field</strong> 关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name: String? = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="comment">//上面这句代码其实和下面的代码是等价的，没有区别。</span></div><div class="line"><span class="keyword">var</span> name: String? = <span class="literal">null</span></div><div class="line">   <span class="keyword">set</span>(value) &#123;</div><div class="line">       field = value</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">get</span>() &#123;</div><div class="line">       <span class="keyword">return</span> field</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>讲到这里我相信大家对幕后字段已经有了一定的了解。</p><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>在kotlin声明一个扩展属性的方法如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> Person.city:String <span class="keyword">get</span>() &#123; <span class="keyword">return</span> <span class="string">"city"</span> &#125;</div></pre></td></tr></table></figure><blockquote><p>注：扩展属性只能用生成自定义set get方法来实现，不能直接用字面量来赋值。所以下面的代码是错的</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> Person.city:String = <span class="string">"city"</span></div></pre></td></tr></table></figure><p>第二句代码是无法编译通过的，那是因为</p><blockquote><p>扩展是静态解析的.扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成 员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数,或者属性。由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就 是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 <strong>get/set</strong> 定义。</p></blockquote><p>静态解析的结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NotNull</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getCity</span><span class="params">(@NotNull Person $receiver)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"city"</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>所以扩展仅仅是可以通过点语法来调用，并不是真正插入类里面，也不存在幕后字段。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>属性可以通过<strong>get</strong>、<strong>set</strong>、<strong>is</strong>（可以替代<strong>get</strong>，用在布尔型属性上）方法或遵循特定命名规范的其他方法访问。</li><li>只读属性和常量不是同一个概念，具体看上头。</li><li>属性可以有一个幕后字段，也可以没有</li><li>扩展是静态解析的，扩展属性是没有幕后字段的</li><li>扩展只是能通过点语法调用而已。</li></ul>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/27/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Kotlin%E4%B8%AD%E5%B1%9E%E6%80%A7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java转Kotlin boolean属性的坑</title>
      <link>https://liyuanbiao100.github.io/2017/10/27/Java%E8%BD%ACKotlin-boolean%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9D%91/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/27/Java%E8%BD%ACKotlin-boolean%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9D%91/</guid>
      <pubDate>Fri, 27 Oct 2017 03:59:22 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;踩坑&quot;&gt;&lt;a href=&quot;#踩坑&quot; class=&quot;headerlink&quot; title=&quot;踩坑&quot;&gt;&lt;/a&gt;踩坑&lt;/h3&gt;&lt;p&gt;假设一个 &lt;code&gt;JavaBean&lt;/code&gt; 类中有 &lt;code&gt;boolean&lt;/code&gt; 类型的字段叫做
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>假设一个 <code>JavaBean</code> 类中有 <code>boolean</code> 类型的字段叫做 <code>enabled</code><br>它生成的<code>setter</code>/<code>getter</code> 方法将是</p><ul><li>setter: <code>setEnabled(boolean enabled)</code></li><li>getter: <code>isEnabled()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> enabled;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.enabled = enabled;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>使用 <code>Android Studio</code> 的 <code>kotlin</code> 插件转换后将生成 <code>isEnabled</code> 属性，而不是 <code>enabled</code> 属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> isEnabled: <span class="built_in">Boolean</span> = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们知道<code>kotlin</code>编译后也是生成<code>class</code>文件，所以也是可以转成<code>java</code>文件的，通过查看反编译后的结果来学习<code>kotlin</code>不失为一种好方法。</p><p>可以在 <code>Android Studio</code> 执行下面的操作将 <code>kotlin</code> 代码重新转成<code>java</code>代码。<br>Tools / Kotlin / Show Kotlin Bytecode / Decompile. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> isEnabled;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.isEnabled;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> var1)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.isEnabled = var1;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到是 <code>isEnabled</code> ，不是 <code>enabled</code>。</p><h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><ul><li><p>我在项目中使用的是<strong>Gson</strong>来解析后台返回来的数据。<strong>Gson</strong>是通过反射字段的名称来赋值的，然而数据中是 <code>enbaled</code> ，代码里是 <code>isEnabled</code> ，它将永远不能被赋值，永远为<code>false</code>，解决方法可以是</p><ul><li>给字段添加 <code>@SerializedName(value = &quot;enbaled&quot;)</code></li><li>直接将 <code>isEnabled</code> 改成 <code>enbaled</code>，保证kotlin的幕后字段与后台返回数据一致即可.</li></ul></li><li><p>如果你项目中用的是<strong>fastjson</strong>，那么需要为每个字段添加<code>setter</code>/<code>getter</code> 方法。<strong>fastjson</strong>是根据<strong>Javabean</strong>属性来赋值的，所以必须保证属性名正确。由于之前<strong>fastjson</strong>出现过序列化成功，但是反序列化失败的bug，致使我放弃使用<strong>fastjson</strong>。虽然<strong>fastjson</strong>以快著称，但是快不是唯一的需求，它只在数据量大的时候有明显差异，数据量小的时候差异几乎可是忽略不计，所以我选择<strong>Gson</strong>。</p></li></ul><h3 id="细谈Java属性"><a href="#细谈Java属性" class="headerlink" title="细谈Java属性"></a>细谈Java属性</h3><p>在Java里面生成 <code>setter</code>/<code>getter</code> 方法是有一定规则的。</p><ul><li>如果类的成员变量的名字是xxx，那么为了更改或获取成员变量的值，即更改或获取属性，在类中可以使用两个方法：<ul><li>getXxx()，用来获取属性xxx。</li><li>setXxx()，用来修改属性xxx.。</li></ul></li><li>对于boolean类型的成员变量，即布尔逻辑类型的属性，允许使用”is”代替上面的”get”。</li><li>类中访问属性的方法都必须是public的，一般属性是private的。</li><li>类中如果有构造方法，那么这个构造方法也是public的并且是无参数的。</li></ul><p>因为Java属性是由 <code>setter</code>/<code>getter</code> 方法决定的，而不是字段。在一个Java类里面，如果有<code>void setName(String name)</code>和<code>String getName()</code>方法，那么可以认为这个类有<code>name</code>这个属性（<strong>可读可写</strong>），如果仅有get，那么这个<code>name</code>属性就是个<strong>只读属性</strong>。即使没有<code>name</code>这个字段也是一样成立的。</p><p>也就是说，对于 <code>boolean</code> 类型，<code>enabled</code> 和 <code>isEnabled</code> 这两个字段生成的<code>setter</code>/<code>getter</code> 方法是一致的。当这两个字段同时存在时，只能针对其中一个生成<code>setter</code>/<code>getter</code> 方法。看下图你就明白了</p><p><img src="/media/15057241768106.jpg" alt=""></p><p><code>isEnabled</code> 已经无法再生成了，因为已经存在了。在项目当中应该避免则这样的命名，选择其一即可。</p>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/27/Java%E8%BD%ACKotlin-boolean%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9D%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>自定义PAC列表规则</title>
      <link>https://liyuanbiao100.github.io/2017/10/25/%E8%87%AA%E5%AE%9A%E4%B9%89PAC%E5%88%97%E8%A1%A8%E8%A7%84%E5%88%99/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/25/%E8%87%AA%E5%AE%9A%E4%B9%89PAC%E5%88%97%E8%A1%A8%E8%A7%84%E5%88%99/</guid>
      <pubDate>Wed, 25 Oct 2017 02:35:05 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h4 id=&quot;规则大概描述如下&quot;&gt;&lt;a href=&quot;#规则大概描述如下&quot; class=&quot;headerlink&quot; title=&quot;规则大概描述如下&quot;&gt;&lt;/a&gt;规则大概描述如下&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通配符支持，如 &lt;em&gt;.example.com/&lt;/em&gt; 实际书写时可省略
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="规则大概描述如下"><a href="#规则大概描述如下" class="headerlink" title="规则大概描述如下"></a>规则大概描述如下</h4><ul><li>通配符支持，如 <em>.example.com/</em> 实际书写时可省略 <em> 如 .example.com/ 意即 </em>.example.com/*</li><li>正则表达式支持，以\开始和结束， 如 [\w]+://example.com\</li><li>例外规则 @@，如 @@.example.com/ 满足@@后规则的地址不使用代理<br>匹配地址开始和结尾 |，如 |<a href="http://example.com、example.com|" target="_blank" rel="external">http://example.com、example.com|</a> 分别表示以 <a href="http://example.com" target="_blank" rel="external">http://example.com</a> 开始和以 example.com 结束的地址</li><li>|| 标记，如 ||example.com 则 <a href="http://example.com" target="_blank" rel="external">http://example.com</a> 、<a href="https://example.com" target="_blank" rel="external">https://example.com</a> 、ftp://example.com 等地址均满足条件，只用于匹配地址开头</li><li>注释 ! 如 ! Comment</li><li>分隔符^，表示除了字母、数字或者 _ - . % 之外的任何字符。如 <a href="http://example.com^" target="_blank" rel="external">http://example.com^</a> ，<a href="http://example.com/" target="_blank" rel="external">http://example.com/</a> 和 <a href="http://example.com:8000/" target="_blank" rel="external">http://example.com:8000/</a> 均满足条件，而 <a href="http://example.com.ar/" target="_blank" rel="external">http://example.com.ar/</a> 不满足条件</li></ul><h4 id="如何使用自定义规则"><a href="#如何使用自定义规则" class="headerlink" title="如何使用自定义规则"></a>如何使用自定义规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">! Put user rules line by line in this file.</div><div class="line">! See https://adblockplus.org/en/filter-cheatsheet</div><div class="line">||amazonaws.com</div><div class="line">||atom.io</div><div class="line">||github.com^</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/25/%E8%87%AA%E5%AE%9A%E4%B9%89PAC%E5%88%97%E8%A1%A8%E8%A7%84%E5%88%99/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 继承与原型链</title>
      <link>https://liyuanbiao100.github.io/2017/10/10/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/10/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <pubDate>Tue, 10 Oct 2017 06:38:04 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;blockquote&gt;
&lt;p&gt;原文:&lt;br&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>原文:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p></blockquote><p>对于有基于类的语言经验的开发人员来说，JavaScript 有点令人困惑 (如Java或C ++) ，因为它是动态的，并且本身不提供一个<code>class</code>实现。（在ES2015/ES6中引入了<code>class</code>关键字，但只是语法糖，JavaScript 仍然是基于原型的）。</p><p>当谈到继承时，JavaScript 只有一种结构：对象。每个对象都有一个私有属性（称之为 [[Prototype]]），它持有一个连接到另一个称为其 <strong>prototype</strong> 对象（原型对象）的链接。该 prototype 对象又具有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>。（译者注：<code>Object.getPrototypeOf(Object.prototype) === null; // true</code>）根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</p><p>JavaScript 中几乎所有的对象都是位于原型链顶端的<code>Object</code>的实例。</p><p>原型继承经常被视为 JavaScript 的一个弱点，但事实上，原型继承模型比经典的继承模型更加强大。例如，在一个原型模型之上构建一个经典模型是相当容易的。</p><h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><blockquote><p>遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指向 someObject的原型。从 ECMAScript 6 开始，[[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <strong>proto</strong>。</p><p>它不应该与函数(function)的func.prototype属性相混淆，func.prototype的作用是使用 new func() 创建的对象的实例的 [[Prototype]]。Object.prototype属性表示Object的原型对象。</p></blockquote><p>这里演示当尝试访问属性时会发生什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 让我们假设我们有一个对象 o, 其有自己的属性 a 和 b：</span></div><div class="line"><span class="comment">// &#123;a: 1, b: 2&#125;</span></div><div class="line"><span class="comment">// o 的原型 o.__proto__有属性 b 和 c：</span></div><div class="line"><span class="comment">// &#123;b: 3, c: 4&#125;</span></div><div class="line"><span class="comment">// 最后, o.__proto__.__proto__ 是 null.</span></div><div class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></div><div class="line"><span class="comment">// 根据定义，null 没有__proto__.</span></div><div class="line"><span class="comment">// 综上，整个原型链如下: </span></div><div class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; null</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></div><div class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为1</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></div><div class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为2</span></div><div class="line"><span class="comment">// o.__proto__上还有一个'b'属性,但是它不会被访问到.这种情况称为"属性遮蔽 (property shadowing)".</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></div><div class="line"><span class="comment">// c是o的自身属性吗？不是，那看看o.__proto__上有没有.</span></div><div class="line"><span class="comment">// c是o.__proto__的自身属性吗？是的,该属性的值为4</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></div><div class="line"><span class="comment">// d是o的自身属性吗？不是,那看看o.__proto__上有没有.</span></div><div class="line"><span class="comment">// d是o.__proto__的自身属性吗？不是，那看看o.__proto__.__proto__上有没有.</span></div><div class="line"><span class="comment">// o.__proto__.__proto__为null，停止搜索，</span></div><div class="line"><span class="comment">// 没有d属性，返回undefined</span></div></pre></td></tr></table></figure><p>将属性设置为对象将创建自己的属性。获取和设置属性的唯一限制是内置 getter 或 setter 的属性。</p><h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 <strong>JavaScript</strong> 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性覆盖”（这种情况相当于其他语言的方法重写）。</p><p>当继承的函数被调用时，<code>this</code> 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.m()); <span class="comment">// 3</span></div><div class="line"><span class="comment">// 当调用 o.m 时,'this'指向了o.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</div><div class="line"><span class="comment">// p是一个对象, p.__proto__是o.</span></div><div class="line"></div><div class="line">p.a = <span class="number">4</span>; <span class="comment">// 创建 p 的自身属性a.</span></div><div class="line"><span class="built_in">console</span>.log(p.m()); <span class="comment">// 5</span></div><div class="line"><span class="comment">// 调用 p.m 时, 'this'指向 p. </span></div><div class="line"><span class="comment">// 又因为 p 继承 o 的 m 函数</span></div><div class="line"><span class="comment">// 此时的'this.a' 即 p.a，即 p 的自身属性 'a'</span></div></pre></td></tr></table></figure><h2 id="使用不同的方法来创建对象和生成原型链"><a href="#使用不同的方法来创建对象和生成原型链" class="headerlink" title="使用不同的方法来创建对象和生成原型链"></a>使用不同的方法来创建对象和生成原型链</h2><h3 id="使用普通语法创建对象"><a href="#使用普通语法创建对象" class="headerlink" title="使用普通语法创建对象"></a>使用普通语法创建对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// o这个对象继承了Object.prototype上面的所有属性</span></div><div class="line"><span class="comment">// 所以可以这样使用 o.hasOwnProperty('a').</span></div><div class="line"><span class="comment">// hasOwnProperty 是Object.prototype的自身属性。</span></div><div class="line"><span class="comment">// Object.prototype的原型为null。</span></div><div class="line"><span class="comment">// 原型链如下:</span></div><div class="line"><span class="comment">// o ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="string">"yo"</span>, <span class="string">"whadup"</span>, <span class="string">"?"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 数组都继承于Array.prototype </span></div><div class="line"><span class="comment">// (indexOf, forEach等方法都是从它继承而来).</span></div><div class="line"><span class="comment">// 原型链如下:</span></div><div class="line"><span class="comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数都继承于Function.prototype</span></div><div class="line"><span class="comment">// (call, bind等方法都是从它继承而来):</span></div><div class="line"><span class="comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></div></pre></td></tr></table></figure><h3 id="使用构造器"><a href="#使用构造器" class="headerlink" title="使用构造器"></a>使用构造器</h3><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">new 操作符</a> 来作用这个函数时，它就可以被称为构造方法（构造函数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertices = [];</div><div class="line">  <span class="keyword">this</span>.edges = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Graph.prototype = &#123;</div><div class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.vertices.push(v);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</div><div class="line"><span class="comment">// g是生成的对象,他的自身属性有'vertices'和'edges'.</span></div><div class="line"><span class="comment">// 在g被实例化时,g.__proto__指向了Graph.prototype.</span></div></pre></td></tr></table></figure><h3 id="使用-Object-create"><a href="#使用-Object-create" class="headerlink" title="使用 Object.create"></a>使用 <code>Object.create</code></h3><p>ECMAScript 5 中引入了一个新方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external"><code>Object.create()</code></a>。可以调用这个方法来创建一个新对象。新对象的原型就是调用 <code>create</code> 方法时传入的第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</div><div class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">// d ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></div></pre></td></tr></table></figure><h3 id="使用-class-关键字"><a href="#使用-class-关键字" class="headerlink" title="使用 class 关键字"></a>使用 <code>class</code> 关键字</h3><p>ECMAScript6 引入了一套新的关键字用来实现 <code>class</code>。使用基于类语言的开发人员会对这些结构感到熟悉，但它们是不同的。JavaScript 仍然基于原型。这些新的关键字包括 <code>class</code>, <code>constructor</code>，<code>static</code>，<code>extends</code> 和 <code>super</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</div><div class="line">    <span class="keyword">super</span>(sideLength, sideLength);</div><div class="line">  &#125;</div><div class="line">  get area() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">  set sideLength(newLength) &#123;</div><div class="line">    <span class="keyword">this</span>.height = newLength;</div><div class="line">    <span class="keyword">this</span>.width = newLength;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</div></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p><p>遍历对象的属性时，原型链上的<strong>每个</strong>可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从<code>Object.prototype</code>继承的 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external"><font color="red">hasOwnProperty</font></a> 方法。下面给出一个具体的例子来说明它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(g.hasOwnProperty(<span class="string">'vertices'</span>));</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(g.hasOwnProperty(<span class="string">'nope'</span>));</div><div class="line"><span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(g.hasOwnProperty(<span class="string">'addVertex'</span>));</div><div class="line"><span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(g.__proto__.hasOwnProperty(<span class="string">'addVertex'</span>));</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external"><font color="red">hasOwnProperty</font></a>是JavaScript中唯一处理属性的东西，并且不支持原型链。</p><p>注意：检查属性是否<code>undefined</code>还不够。该属性可能存在，但其值恰好设置为<code>undefined</code>。</p><h3 id="错误实践：扩展原生对象的原型"><a href="#错误实践：扩展原生对象的原型" class="headerlink" title="错误实践：扩展原生对象的原型"></a>错误实践：扩展原生对象的原型</h3><p>经常使用的一个错误实践是扩展<code>Object.prototype</code>或其他内置原型。</p><p>这种技术被称为猴子补丁并且会破坏封装。尽管一些流行的框架（如 Prototype.js）在使用该技术，但仍然没有足够好的理由使用附加的非标准方法来混入内置原型。</p><p>扩展内置原型的唯一理由是支持JavaScript 引擎的新特性，如<code>Array.forEach</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>B</code> 继承自 <code>A</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.varA = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 以上函数 A 的定义中，既然 A.prototype.varA 总是会被 this.varA 遮蔽，</span></div><div class="line"><span class="comment">// 那么将 varA 加入到原型（prototype）中的目的是什么？</span></div><div class="line">A.prototype = &#123;</div><div class="line">  varA : <span class="literal">null</span>,  </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">既然它没有任何作用，干嘛不将 varA 从原型（prototype）去掉 ? </span></div><div class="line"><span class="comment">也许作为一种在隐藏类中优化分配空间的考虑 ?</span></div><div class="line"><span class="comment">https://developers.google.com/speed/articles/optimizing-javascript </span></div><div class="line"><span class="comment">如果varA并不是在每个实例中都被初始化，那这样做将是有效果的。</span></div><div class="line"><span class="comment">*/</span></div><div class="line">  doSomething : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  A.call(<span class="keyword">this</span>, a);</div><div class="line">  <span class="keyword">this</span>.varB = b;</div><div class="line">&#125;</div><div class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype, &#123;</div><div class="line">  varB : &#123;</div><div class="line">    value: <span class="literal">null</span>, </div><div class="line">    enumerable: <span class="literal">true</span>, </div><div class="line">    configurable: <span class="literal">true</span>, </div><div class="line">    writable: <span class="literal">true</span> </div><div class="line">  &#125;,</div><div class="line">  doSomething : &#123; </div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// override</span></div><div class="line">      A.prototype.doSomething.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </div><div class="line">      <span class="comment">// call super</span></div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>, </div><div class="line">    writable: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">B.prototype.constructor = B;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</div><div class="line">b.doSomething();</div></pre></td></tr></table></figure><p>最重要的部分是：</p><ul><li>类型被定义在 <code>.prototype</code> 中</li><li>用 <code>Object.create()</code> 来继承</li></ul><h2 id="prototype和Object-getPrototypeOf"><a href="#prototype和Object-getPrototypeOf" class="headerlink" title="prototype和Object.getPrototypeOf"></a><code>prototype</code>和<code>Object.getPrototypeOf</code></h2><p>对于从 Java 或 C++ 转过来的开发人员来说 JavaScript 会有点让人困惑，因为它全部都是动态的，都是运行时，而且不存在类（classes）。所有的都是实例（对象）。即使我们模拟出的 “类（classes）”，也只是一个函数对象。</p><p>你可能已经注意到我们的<code>function A</code>有一个叫做<code>prototype</code>的特殊属性。该特殊属性可与 JavaScript 的 new 操作符一起使用。对原型对象的引用被复制到新实例的内部<code>[[Prototype]]</code>属性。例如，当执行<code>var a1 = new A()</code>时，JavaScript（在内存中创建对象之前，并且在运行函数A()之前）定义了它）设置a1.<code>[[Prototype]] = A.prototype</code>。然后当您访问实例的属性时，JavaScript首先会检查它们是否直接存在于该对象上，如果不存在，则会<code>[[Prototype]]</code>中查找。这意味着你在<code>prototype</code>中定义的所有内容都可以由所有实例有效共享，你甚至可以稍后更改部分<code>prototype</code>，并在所有现有实例中显示更改（如果需要）。</p><p>像上面的例子中，如果你执行<code>var a1 = new A(); var a2 = new A();</code> 那么 <code>a1.doSomething</code>事实上会指向<code>Object.getPrototypeOf(a1).doSomething</code>，它就是你在 <code>A.prototype.doSomething</code> 中定义的内容。比如：<code>Object.getPrototypeOf(a1).doSomething == Object.getPrototypeOf(a2).doSomething == A.prototype.doSomething</code>。</p><p>简而言之， <code>prototype</code>是用于类型的，而 <code>Object.getPrototypeOf()</code> 是用于实例的（instances），两者功能一致。</p><p><code>[[Prototype]]</code> 看起来就像递归引用， 如<code>a1.doSomething，Object.getPrototypeOf(a1).doSomething，Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething</code> 等等等， 直到它被找到或<code>Object.getPrototypeOf</code>返回 <code>null</code>。</p><p>因此，当你执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure><p>JavaScript 实际上执行的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.__proto__ = Foo.prototype;</div><div class="line">Foo.call(o);</div></pre></td></tr></table></figure><p>（或者类似上面这样的），然后当你执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.someProp;</div></pre></td></tr></table></figure><p>它检查o是否具有<code>someProp</code>属性。如果没有，它会查找 <code>Object.getPrototypeOf(o).someProp</code>，如果仍旧没有，它会继续查找 <code>Object.getPrototypeOf(Object.getPrototypeOf(o)).someProp</code>。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在用原型继承编写复杂代码之前，了解原型继承模型非常<strong>重要</strong>。同时，要注意代码中的原型链的长度，并在必要时将其分解，以避免潜在的性能问题。此外，永远<strong>不要</strong>扩展原生对象的原型，除非是为了兼容新的JavaScript特性。</p>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/10/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ThreadLocal详解</title>
      <link>https://liyuanbiao100.github.io/2017/10/10/ThreadLocal%E8%AF%A6%E8%A7%A3/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/10/ThreadLocal%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Tue, 10 Oct 2017 04:59:59 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ThreadLocal类位于java.lang包下，jdk1.2开始引入。ThreadLocal为每个使用该类变量的线程提供单独的副本，线程之间不会互相影响。就是说在A线程设置的值只能在A线程读取到，在B线程是读取不到的。</p><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。<br>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>这个类一共提供了四个方法。</p><ul><li><code>set(T value)</code> 将此线程局部变量的当前线程副本中的值设置为指定值。</li><li><code>get()</code>  返回此线程局部变量的当前线程副本中的值。</li><li><code>remove()</code>  移除此线程局部变量当前线程的值。</li><li><code>initialValue()</code> 返回此线程局部变量的当前线程的“初始值”。该实现返回 null；如果程序员希望线程局部变量具有 <code>null</code> 以外的值，则必须为 ThreadLocal <strong>创建子类</strong>，并<strong>重写</strong>此方法。通常将使用<strong>匿名内部类</strong>完成此操作。</li></ul><p>下面看看ThreadLocal是如何解决这一问题的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">        threadLocal.set(<span class="string">"hello"</span>);</div><div class="line">        printValue(); <span class="comment">//打印 main -&gt; hello</span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                printValue(); <span class="comment">//打印 Thread-0 -&gt; null</span></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -&gt; "</span> + threadLocal.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ThreadLocalDemo demo = <span class="keyword">new</span> ThreadLocalDemo();</div><div class="line">        demo.test();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//防止程序结束</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面代码中可以看到不同线程获取到的值是不一样的，在主线程设置的值只能在主线程获取到，在子线程返回了一个<code>null</code>。同时把<strong>ThreadLocal</strong>生明为全局变量，也不会影响各线程之间的值。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>下面的代码取自<strong>ThreadLocal</strong>类，展示了最基本的几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每个Thread都有自己的ThreadLocalMap</span></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="comment">//在不同线程调用这个方法获取到的ThreadLocalMap对象是不一样的，</span></div><div class="line">    <span class="comment">//所以从Map取到的对象更加不可能是一样了。</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">//用当前对象作为key存储value</span></div><div class="line">        map.set(<span class="keyword">this</span>, value); </div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//用当前对象作为key获取value</span></div><div class="line">        <span class="comment">//由于是用当前对象作为key，所以一个ThreadLocal对象只能存储一个值。</span></div><div class="line">        <span class="comment">//如果想要存储几个值可以多用几个ThreadLocal。</span></div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</div><div class="line">        <span class="comment">//用当前对象作为key移除value</span></div><div class="line">         m.remove(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码可以很容易看出<strong>ThreadLocal</strong>的原理，但是由于<strong>ThreadLocal</strong>的代码太多，这只是很小的一部分，为了便于大家理解问题，我写了一个类模拟<strong>ThreadLocal</strong>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//每个线程有单独的Map来保证变量在不同线程之间互不影响</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Thread, Map&lt;ThreadLocal, Object&gt;&gt; tMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread thread = Thread.currentThread();</div><div class="line">        Map&lt;ThreadLocal, Object&gt; map = tMap.get(thread);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            map.put(<span class="keyword">this</span>, value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">            tMap.put(thread, map);</div><div class="line">            map.put(<span class="keyword">this</span>, value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread thread = Thread.currentThread();</div><div class="line">        Map&lt;ThreadLocal, Object&gt; map = tMap.get(thread);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (T) map.get(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread thread = Thread.currentThread();</div><div class="line">        Map&lt;ThreadLocal, Object&gt; map = tMap.get(thread);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">            map.remove(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每个<strong>Thread</strong>都有自己的<strong>ThreadLocalMap</strong>，存储<strong>value</strong>的时候会存储到自己的<strong>ThreadLocalMap</strong>，所以在哪个线程设置的<strong>value</strong>就只能在哪个线程获取到，其他<strong>Thread</strong>是获取不到的。因为<strong>ThreadLocal</strong>类用<code>this</code>当做<strong>key</strong>，所以每个<strong>ThreadLocal</strong>最多存储一个<strong>value</strong>。如果想要存储几个值可以多用几个<strong>ThreadLocal</strong>。</p>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/10/ThreadLocal%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 模板字符串</title>
      <link>https://liyuanbiao100.github.io/2017/10/09/JavaScript-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <guid>https://liyuanbiao100.github.io/2017/10/09/JavaScript-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <pubDate>Mon, 09 Oct 2017 06:44:25 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">`string text`</span></div><div class="line"></div><div class="line"><span class="string">`string text line 1</span></div><div class="line"><span class="string"> string text line 2`</span></div><div class="line"></div><div class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></div><div class="line"></div><div class="line">tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></div></pre></td></tr></table></figure><blockquote><p>Note: 模板字面量也可以使用三元运算符( condition ?  true : false ) 和  嵌套 nested！</p></blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法(<code>${expression}</code>)的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">`\``</span> === <span class="string">"`"</span> <span class="comment">// --&gt; true</span></div></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"string text line 1\n\</span></div><div class="line"><span class="string">string text line 2"</span>);</div><div class="line"><span class="comment">// "string text line 1</span></div><div class="line"><span class="comment">// string text line 2"</span></div></pre></td></tr></table></figure><p>要获得同样效果的多行字符串，只需使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></div><div class="line"><span class="string">string text line 2`</span>);</div><div class="line"><span class="comment">// "string text line 1</span></div><div class="line"><span class="comment">// string text line 2"</span></div></pre></td></tr></table></figure><h3 id="表达式插补"><a href="#表达式插补" class="headerlink" title="表达式插补"></a>表达式插补</h3><p>在普通字符串中嵌入表达式，必须使用如下语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Fifteen is "</span> + (a + b) + <span class="string">" and\nnot "</span> + (<span class="number">2</span> * a + b) + <span class="string">"."</span>);</div><div class="line"><span class="comment">// "Fifteen is 15 and</span></div><div class="line"><span class="comment">// not 20."</span></div></pre></td></tr></table></figure><p>现在通过模板字符串，我们可以使用一种更优雅的方式来表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">$&#123;a + b&#125;</span> and\nnot <span class="subst">$&#123;<span class="number">2</span> * a + b&#125;</span>.`</span>);</div><div class="line"><span class="comment">// "Fifteen is 15 and</span></div><div class="line"><span class="comment">// not 20."</span></div></pre></td></tr></table></figure><h3 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h3><p>模板字符串的一种更高级的形式称为带标签的模板字符串。它允许您通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组（在本例中分别为“Hello”,“world”和””）；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式（在这里分别为“15”和“50”）。 最后，标签函数返回处理好的字符串。在下面的例子中，命名这个标签并没有什么特殊的地方，这个函数的名字可以是任何你想要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">0</span>]); <span class="comment">// "Hello "</span></div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">1</span>]); <span class="comment">// " world "</span></div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">2</span>]); <span class="comment">// ""</span></div><div class="line">  <span class="built_in">console</span>.log(values[<span class="number">0</span>]);  <span class="comment">// 15</span></div><div class="line">  <span class="built_in">console</span>.log(values[<span class="number">1</span>]);  <span class="comment">// 50</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"Bazinga!"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// "Bazinga!"</span></div></pre></td></tr></table></figure><p>正如下面例子所展示的，标签函数并不一定需要返回一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">strings, ...keys</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dict = values[values.length - <span class="number">1</span>] || &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> result = [strings[<span class="number">0</span>]];</div><div class="line">    keys.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key, i</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> value = <span class="built_in">Number</span>.isInteger(key) ? values[key] : dict[key];</div><div class="line">      result.push(value, strings[i + <span class="number">1</span>]);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> result.join(<span class="string">''</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> t1Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span><span class="subst">$&#123;<span class="number">1</span>&#125;</span><span class="subst">$&#123;<span class="number">0</span>&#125;</span>!`</span>;</div><div class="line">t1Closure(<span class="string">'Y'</span>, <span class="string">'A'</span>);  <span class="comment">// "YAY!" </span></div><div class="line"><span class="keyword">var</span> t2Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span> <span class="subst">$&#123;<span class="string">'foo'</span>&#125;</span>!`</span>;</div><div class="line">t2Closure(<span class="string">'Hello'</span>, &#123;<span class="attr">foo</span>: <span class="string">'World'</span>&#125;);  <span class="comment">// "Hello World!"</span></div></pre></td></tr></table></figure><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]); </div><div class="line">  <span class="comment">// "string text line 1 \\n string text line 2"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`string text line 1 \n string text line 2`</span>;</div></pre></td></tr></table></figure><p>另外，使用<code>String.raw()</code>方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n5!"</span></div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/10/09/JavaScript-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android Studio 自动检查依赖库是否有新版本</title>
      <link>https://liyuanbiao100.github.io/2017/09/12/Android-Studio-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B0%E7%89%88%E6%9C%AC/</link>
      <guid>https://liyuanbiao100.github.io/2017/09/12/Android-Studio-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B0%E7%89%88%E6%9C%AC/</guid>
      <pubDate>Tue, 12 Sep 2017 07:45:32 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;strong&gt;Preferences&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Editor&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Inspections&lt;/strong&gt; -&amp;gt; “&lt;strong&gt;Android &amp;gt; Lint &amp;gt;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>Preferences</strong> -&gt; <strong>Editor</strong> -&gt; <strong>Inspections</strong> -&gt; “<strong>Android &gt; Lint &gt; Correctness</strong>” -&gt; <strong>Newer Library Versions Available (available for Analyze|Inspect Code)</strong>    <font color="red"><strong>这一项打上勾</strong></font>。<br><img src="/media/15051956933872/15051957572874.png" alt=""></p><p>如果想要检查的话，同时按住 <strong>shift+alt+command+i</strong> ，会弹出 <strong>Enter Inspect name</strong> 窗口。输入 <strong>Newer Library Versions Available</strong> ，一般不用输入全部的，输入 <strong>Newer</strong> 就好了，包含 <strong>Newer</strong> 的选项就会全部搜索出来。<br><img src="/media/15051956933872/15051957698386.png" alt=""></p><p>选择 <strong>Newer Library Versions Available</strong> 这一项<br><img src="/media/15051956933872/15051957934804.png" alt=""></p><p>选择你需要检查的模块</p><ul><li><strong>Whole project</strong>  -&gt;完整的模块。 </li><li><strong>Module</strong> -&gt; 单独的一个模块</li><li><strong>File</strong> -&gt; 单独的一个文件</li><li><strong>Custom scope</strong> -&gt; 自定义范围</li></ul><p>我这里选择 <strong>Whole project</strong> ，点击 <strong>OK</strong> 就可以开始检查了。<br><img src="/media/15051956933872/15051958715001.jpg" alt=""></p><p>点击 <strong>Update to [VersionName]</strong> 就可以把版本号替换到最新版本。<br>最后点击 <strong>Sync Now</strong> 同步一下项目<br><img src="/media/15051956933872/15051961312946.jpg" alt=""></p><p>需要注意升级版本后，新版本可能不兼容旧版本，需要仔细检查代码，防止出错。</p>]]></content:encoded>
      
      <comments>https://liyuanbiao100.github.io/2017/09/12/Android-Studio-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5%E4%BE%9D%E8%B5%96%E5%BA%93%E6%98%AF%E5%90%A6%E6%9C%89%E6%96%B0%E7%89%88%E6%9C%AC/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
